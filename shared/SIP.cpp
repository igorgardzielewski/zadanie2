//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `SIP.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <SIP.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::std::string iceC_SIP_TramStop_ids[2] =
{
    "::Ice::Object",
    "::SIP::TramStop"
};
const ::std::string iceC_SIP_TramStop_ops[] =
{
    "RegisterPassenger",
    "UnregisterPassenger",
    "UpdateTramInfo",
    "getName",
    "getNextTrams",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_SIP_TramStop_getName_name = "getName";
const ::std::string iceC_SIP_TramStop_getNextTrams_name = "getNextTrams";
const ::std::string iceC_SIP_TramStop_RegisterPassenger_name = "RegisterPassenger";
const ::std::string iceC_SIP_TramStop_UnregisterPassenger_name = "UnregisterPassenger";
const ::std::string iceC_SIP_TramStop_UpdateTramInfo_name = "UpdateTramInfo";

const ::std::string iceC_SIP_Line_ids[2] =
{
    "::Ice::Object",
    "::SIP::Line"
};
const ::std::string iceC_SIP_Line_ops[] =
{
    "getName",
    "getStops",
    "getTrams",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "registerTram",
    "setStops",
    "unregisterTram"
};
const ::std::string iceC_SIP_Line_getTrams_name = "getTrams";
const ::std::string iceC_SIP_Line_getStops_name = "getStops";
const ::std::string iceC_SIP_Line_registerTram_name = "registerTram";
const ::std::string iceC_SIP_Line_unregisterTram_name = "unregisterTram";
const ::std::string iceC_SIP_Line_setStops_name = "setStops";
const ::std::string iceC_SIP_Line_getName_name = "getName";

const ::std::string iceC_SIP_LineFactory_ids[2] =
{
    "::Ice::Object",
    "::SIP::LineFactory"
};
const ::std::string iceC_SIP_LineFactory_ops[] =
{
    "createLine",
    "getLoad",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_SIP_LineFactory_createLine_name = "createLine";
const ::std::string iceC_SIP_LineFactory_getLoad_name = "getLoad";

const ::std::string iceC_SIP_StopFactory_ids[2] =
{
    "::Ice::Object",
    "::SIP::StopFactory"
};
const ::std::string iceC_SIP_StopFactory_ops[] =
{
    "createStop",
    "getLoad",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_SIP_StopFactory_createStop_name = "createStop";
const ::std::string iceC_SIP_StopFactory_getLoad_name = "getLoad";

const ::std::string iceC_SIP_MPK_ids[2] =
{
    "::Ice::Object",
    "::SIP::MPK"
};
const ::std::string iceC_SIP_MPK_ops[] =
{
    "getDepo",
    "getDepos",
    "getLines",
    "getTramStop",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "registerDepo",
    "registerLineFactory",
    "registerStopFactory",
    "unregisterDepo",
    "unregisterLineFactory",
    "unregisterStopFactory"
};
const ::std::string iceC_SIP_MPK_getTramStop_name = "getTramStop";
const ::std::string iceC_SIP_MPK_registerDepo_name = "registerDepo";
const ::std::string iceC_SIP_MPK_unregisterDepo_name = "unregisterDepo";
const ::std::string iceC_SIP_MPK_getDepo_name = "getDepo";
const ::std::string iceC_SIP_MPK_getDepos_name = "getDepos";
const ::std::string iceC_SIP_MPK_getLines_name = "getLines";
const ::std::string iceC_SIP_MPK_registerLineFactory_name = "registerLineFactory";
const ::std::string iceC_SIP_MPK_unregisterLineFactory_name = "unregisterLineFactory";
const ::std::string iceC_SIP_MPK_registerStopFactory_name = "registerStopFactory";
const ::std::string iceC_SIP_MPK_unregisterStopFactory_name = "unregisterStopFactory";

const ::std::string iceC_SIP_Depo_ids[2] =
{
    "::Ice::Object",
    "::SIP::Depo"
};
const ::std::string iceC_SIP_Depo_ops[] =
{
    "TramOffline",
    "TramOnline",
    "getName",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_SIP_Depo_TramOnline_name = "TramOnline";
const ::std::string iceC_SIP_Depo_TramOffline_name = "TramOffline";
const ::std::string iceC_SIP_Depo_getName_name = "getName";

const ::std::string iceC_SIP_Tram_ids[2] =
{
    "::Ice::Object",
    "::SIP::Tram"
};
const ::std::string iceC_SIP_Tram_ops[] =
{
    "RegisterPassenger",
    "UnregisterPassenger",
    "getLine",
    "getLocation",
    "getNextStops",
    "getStockNumber",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setLine"
};
const ::std::string iceC_SIP_Tram_getLocation_name = "getLocation";
const ::std::string iceC_SIP_Tram_getLine_name = "getLine";
const ::std::string iceC_SIP_Tram_setLine_name = "setLine";
const ::std::string iceC_SIP_Tram_getNextStops_name = "getNextStops";
const ::std::string iceC_SIP_Tram_RegisterPassenger_name = "RegisterPassenger";
const ::std::string iceC_SIP_Tram_UnregisterPassenger_name = "UnregisterPassenger";
const ::std::string iceC_SIP_Tram_getStockNumber_name = "getStockNumber";

const ::std::string iceC_SIP_Passenger_ids[2] =
{
    "::Ice::Object",
    "::SIP::Passenger"
};
const ::std::string iceC_SIP_Passenger_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "updateStopInfo",
    "updateTramInfo"
};
const ::std::string iceC_SIP_Passenger_updateTramInfo_name = "updateTramInfo";
const ::std::string iceC_SIP_Passenger_updateStopInfo_name = "updateStopInfo";

}

bool
SIP::TramStop::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_TramStop_ids, iceC_SIP_TramStop_ids + 2, s);
}

::std::vector<::std::string>
SIP::TramStop::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_SIP_TramStop_ids[0], &iceC_SIP_TramStop_ids[2]);
}

::std::string
SIP::TramStop::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::TramStop::ice_staticId()
{
    static const ::std::string typeId = "::SIP::TramStop";
    return typeId;
}

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_getNextTrams(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_howMany;
    istr->readAll(iceP_howMany);
    inS.endReadParams();
    TramList ret = this->getNextTrams(iceP_howMany, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_RegisterPassenger(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PassengerPrx> iceP_p;
    istr->readAll(iceP_p);
    inS.endReadParams();
    this->RegisterPassenger(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_UnregisterPassenger(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PassengerPrx> iceP_p;
    istr->readAll(iceP_p);
    inS.endReadParams();
    this->UnregisterPassenger(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_UpdateTramInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<TramPrx> iceP_tram;
    Time iceP_time;
    istr->readAll(iceP_tram, iceP_time);
    inS.endReadParams();
    this->UpdateTramInfo(::std::move(iceP_tram), ::std::move(iceP_time), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_TramStop_ops, iceC_SIP_TramStop_ops + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_TramStop_ops)
    {
        case 0:
        {
            return _iceD_RegisterPassenger(in, current);
        }
        case 1:
        {
            return _iceD_UnregisterPassenger(in, current);
        }
        case 2:
        {
            return _iceD_UpdateTramInfo(in, current);
        }
        case 3:
        {
            return _iceD_getName(in, current);
        }
        case 4:
        {
            return _iceD_getNextTrams(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
SIP::Line::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_Line_ids, iceC_SIP_Line_ids + 2, s);
}

::std::vector<::std::string>
SIP::Line::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_SIP_Line_ids[0], &iceC_SIP_Line_ids[2]);
}

::std::string
SIP::Line::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::Line::ice_staticId()
{
    static const ::std::string typeId = "::SIP::Line";
    return typeId;
}

/// \cond INTERNAL
bool
SIP::Line::_iceD_getTrams(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    TramList ret = this->getTrams(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_getStops(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StopList ret = this->getStops(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_registerTram(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<TramPrx> iceP_tram;
    istr->readAll(iceP_tram);
    inS.endReadParams();
    this->registerTram(::std::move(iceP_tram), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_unregisterTram(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<TramPrx> iceP_tram;
    istr->readAll(iceP_tram);
    inS.endReadParams();
    this->unregisterTram(::std::move(iceP_tram), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_setStops(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StopList iceP_sl;
    istr->readAll(iceP_sl);
    inS.endReadParams();
    this->setStops(::std::move(iceP_sl), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_Line_ops, iceC_SIP_Line_ops + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_Line_ops)
    {
        case 0:
        {
            return _iceD_getName(in, current);
        }
        case 1:
        {
            return _iceD_getStops(in, current);
        }
        case 2:
        {
            return _iceD_getTrams(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_registerTram(in, current);
        }
        case 8:
        {
            return _iceD_setStops(in, current);
        }
        case 9:
        {
            return _iceD_unregisterTram(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
SIP::LineFactory::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_LineFactory_ids, iceC_SIP_LineFactory_ids + 2, s);
}

::std::vector<::std::string>
SIP::LineFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_SIP_LineFactory_ids[0], &iceC_SIP_LineFactory_ids[2]);
}

::std::string
SIP::LineFactory::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::LineFactory::ice_staticId()
{
    static const ::std::string typeId = "::SIP::LineFactory";
    return typeId;
}

/// \cond INTERNAL
bool
SIP::LineFactory::_iceD_createLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::shared_ptr<LinePrx> ret = this->createLine(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::LineFactory::_iceD_getLoad(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    double ret = this->getLoad(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::LineFactory::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_LineFactory_ops, iceC_SIP_LineFactory_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_LineFactory_ops)
    {
        case 0:
        {
            return _iceD_createLine(in, current);
        }
        case 1:
        {
            return _iceD_getLoad(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
SIP::StopFactory::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_StopFactory_ids, iceC_SIP_StopFactory_ids + 2, s);
}

::std::vector<::std::string>
SIP::StopFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_SIP_StopFactory_ids[0], &iceC_SIP_StopFactory_ids[2]);
}

::std::string
SIP::StopFactory::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::StopFactory::ice_staticId()
{
    static const ::std::string typeId = "::SIP::StopFactory";
    return typeId;
}

/// \cond INTERNAL
bool
SIP::StopFactory::_iceD_createStop(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::shared_ptr<StopPrx> ret = this->createStop(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::StopFactory::_iceD_getLoad(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    double ret = this->getLoad(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::StopFactory::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_StopFactory_ops, iceC_SIP_StopFactory_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_StopFactory_ops)
    {
        case 0:
        {
            return _iceD_createStop(in, current);
        }
        case 1:
        {
            return _iceD_getLoad(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
SIP::MPK::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_MPK_ids, iceC_SIP_MPK_ids + 2, s);
}

::std::vector<::std::string>
SIP::MPK::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_SIP_MPK_ids[0], &iceC_SIP_MPK_ids[2]);
}

::std::string
SIP::MPK::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::MPK::ice_staticId()
{
    static const ::std::string typeId = "::SIP::MPK";
    return typeId;
}

/// \cond INTERNAL
bool
SIP::MPK::_iceD_getTramStop(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::shared_ptr<TramStopPrx> ret = this->getTramStop(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_registerDepo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<DepoPrx> iceP_depo;
    istr->readAll(iceP_depo);
    inS.endReadParams();
    this->registerDepo(::std::move(iceP_depo), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_unregisterDepo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<DepoPrx> iceP_depo;
    istr->readAll(iceP_depo);
    inS.endReadParams();
    this->unregisterDepo(::std::move(iceP_depo), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_getDepo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::shared_ptr<DepoPrx> ret = this->getDepo(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_getDepos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    DepoList ret = this->getDepos(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_getLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    LineList ret = this->getLines(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_registerLineFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<LineFactoryPrx> iceP_lf;
    istr->readAll(iceP_lf);
    inS.endReadParams();
    this->registerLineFactory(::std::move(iceP_lf), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_unregisterLineFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<LineFactoryPrx> iceP_lf;
    istr->readAll(iceP_lf);
    inS.endReadParams();
    this->unregisterLineFactory(::std::move(iceP_lf), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_registerStopFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<StopFactoryPrx> iceP_lf;
    istr->readAll(iceP_lf);
    inS.endReadParams();
    this->registerStopFactory(::std::move(iceP_lf), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_unregisterStopFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<StopFactoryPrx> iceP_lf;
    istr->readAll(iceP_lf);
    inS.endReadParams();
    this->unregisterStopFactory(::std::move(iceP_lf), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_MPK_ops, iceC_SIP_MPK_ops + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_MPK_ops)
    {
        case 0:
        {
            return _iceD_getDepo(in, current);
        }
        case 1:
        {
            return _iceD_getDepos(in, current);
        }
        case 2:
        {
            return _iceD_getLines(in, current);
        }
        case 3:
        {
            return _iceD_getTramStop(in, current);
        }
        case 4:
        {
            return _iceD_ice_id(in, current);
        }
        case 5:
        {
            return _iceD_ice_ids(in, current);
        }
        case 6:
        {
            return _iceD_ice_isA(in, current);
        }
        case 7:
        {
            return _iceD_ice_ping(in, current);
        }
        case 8:
        {
            return _iceD_registerDepo(in, current);
        }
        case 9:
        {
            return _iceD_registerLineFactory(in, current);
        }
        case 10:
        {
            return _iceD_registerStopFactory(in, current);
        }
        case 11:
        {
            return _iceD_unregisterDepo(in, current);
        }
        case 12:
        {
            return _iceD_unregisterLineFactory(in, current);
        }
        case 13:
        {
            return _iceD_unregisterStopFactory(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
SIP::Depo::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_Depo_ids, iceC_SIP_Depo_ids + 2, s);
}

::std::vector<::std::string>
SIP::Depo::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_SIP_Depo_ids[0], &iceC_SIP_Depo_ids[2]);
}

::std::string
SIP::Depo::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::Depo::ice_staticId()
{
    static const ::std::string typeId = "::SIP::Depo";
    return typeId;
}

/// \cond INTERNAL
bool
SIP::Depo::_iceD_TramOnline(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<TramPrx> iceP_t;
    istr->readAll(iceP_t);
    inS.endReadParams();
    this->TramOnline(::std::move(iceP_t), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Depo::_iceD_TramOffline(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<TramPrx> iceP_t;
    istr->readAll(iceP_t);
    inS.endReadParams();
    this->TramOffline(::std::move(iceP_t), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Depo::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Depo::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_Depo_ops, iceC_SIP_Depo_ops + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_Depo_ops)
    {
        case 0:
        {
            return _iceD_TramOffline(in, current);
        }
        case 1:
        {
            return _iceD_TramOnline(in, current);
        }
        case 2:
        {
            return _iceD_getName(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
SIP::Tram::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_Tram_ids, iceC_SIP_Tram_ids + 2, s);
}

::std::vector<::std::string>
SIP::Tram::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_SIP_Tram_ids[0], &iceC_SIP_Tram_ids[2]);
}

::std::string
SIP::Tram::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::Tram::ice_staticId()
{
    static const ::std::string typeId = "::SIP::Tram";
    return typeId;
}

/// \cond INTERNAL
bool
SIP::Tram::_iceD_getLocation(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<TramStopPrx> ret = this->getLocation(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_getLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<LinePrx> ret = this->getLine(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_setLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<LinePrx> iceP_line;
    istr->readAll(iceP_line);
    inS.endReadParams();
    this->setLine(::std::move(iceP_line), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_getNextStops(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_howMany;
    istr->readAll(iceP_howMany);
    inS.endReadParams();
    StopList ret = this->getNextStops(iceP_howMany, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_RegisterPassenger(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PassengerPrx> iceP_p;
    istr->readAll(iceP_p);
    inS.endReadParams();
    this->RegisterPassenger(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_UnregisterPassenger(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PassengerPrx> iceP_p;
    istr->readAll(iceP_p);
    inS.endReadParams();
    this->UnregisterPassenger(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_getStockNumber(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getStockNumber(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_Tram_ops, iceC_SIP_Tram_ops + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_Tram_ops)
    {
        case 0:
        {
            return _iceD_RegisterPassenger(in, current);
        }
        case 1:
        {
            return _iceD_UnregisterPassenger(in, current);
        }
        case 2:
        {
            return _iceD_getLine(in, current);
        }
        case 3:
        {
            return _iceD_getLocation(in, current);
        }
        case 4:
        {
            return _iceD_getNextStops(in, current);
        }
        case 5:
        {
            return _iceD_getStockNumber(in, current);
        }
        case 6:
        {
            return _iceD_ice_id(in, current);
        }
        case 7:
        {
            return _iceD_ice_ids(in, current);
        }
        case 8:
        {
            return _iceD_ice_isA(in, current);
        }
        case 9:
        {
            return _iceD_ice_ping(in, current);
        }
        case 10:
        {
            return _iceD_setLine(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
SIP::Passenger::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_Passenger_ids, iceC_SIP_Passenger_ids + 2, s);
}

::std::vector<::std::string>
SIP::Passenger::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_SIP_Passenger_ids[0], &iceC_SIP_Passenger_ids[2]);
}

::std::string
SIP::Passenger::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::Passenger::ice_staticId()
{
    static const ::std::string typeId = "::SIP::Passenger";
    return typeId;
}

/// \cond INTERNAL
bool
SIP::Passenger::_iceD_updateTramInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<TramPrx> iceP_tram;
    StopList iceP_stops;
    istr->readAll(iceP_tram, iceP_stops);
    inS.endReadParams();
    this->updateTramInfo(::std::move(iceP_tram), ::std::move(iceP_stops), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Passenger::_iceD_updateStopInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<StopPrx> iceP_stop;
    TramList iceP_trams;
    istr->readAll(iceP_stop, iceP_trams);
    inS.endReadParams();
    this->updateStopInfo(::std::move(iceP_stop), ::std::move(iceP_trams), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Passenger::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_Passenger_ops, iceC_SIP_Passenger_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_Passenger_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_updateStopInfo(in, current);
        }
        case 5:
        {
            return _iceD_updateTramInfo(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramStopPrx::_iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_TramStop_getName_name);
    outAsync->invoke(iceC_SIP_TramStop_getName_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramStopPrx::_iceI_getNextTrams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::TramList>>& outAsync, int iceP_howMany, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_TramStop_getNextTrams_name);
    outAsync->invoke(iceC_SIP_TramStop_getNextTrams_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_howMany);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramStopPrx::_iceI_RegisterPassenger(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<PassengerPrx>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_TramStop_RegisterPassenger_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramStopPrx::_iceI_UnregisterPassenger(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<PassengerPrx>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_TramStop_UnregisterPassenger_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramStopPrx::_iceI_UpdateTramInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<TramPrx>& iceP_tram, const Time& iceP_time, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_TramStop_UpdateTramInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_tram, iceP_time);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
SIP::TramStopPrx::_newInstance() const
{
    return ::IceInternal::createProxy<TramStopPrx>();
}
/// \endcond

const ::std::string&
SIP::TramStopPrx::ice_staticId()
{
    return TramStop::ice_staticId();
}

/// \cond INTERNAL
void
SIP::LinePrx::_iceI_getTrams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::TramList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_Line_getTrams_name);
    outAsync->invoke(iceC_SIP_Line_getTrams_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::LinePrx::_iceI_getStops(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::StopList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_Line_getStops_name);
    outAsync->invoke(iceC_SIP_Line_getStops_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::LinePrx::_iceI_registerTram(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<TramPrx>& iceP_tram, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Line_registerTram_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_tram);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::LinePrx::_iceI_unregisterTram(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<TramPrx>& iceP_tram, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Line_unregisterTram_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_tram);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::LinePrx::_iceI_setStops(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const StopList& iceP_sl, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Line_setStops_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_sl);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::LinePrx::_iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_Line_getName_name);
    outAsync->invoke(iceC_SIP_Line_getName_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
SIP::LinePrx::_newInstance() const
{
    return ::IceInternal::createProxy<LinePrx>();
}
/// \endcond

const ::std::string&
SIP::LinePrx::ice_staticId()
{
    return Line::ice_staticId();
}

/// \cond INTERNAL
void
SIP::LineFactoryPrx::_iceI_createLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::LinePrx>>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_LineFactory_createLine_name);
    outAsync->invoke(iceC_SIP_LineFactory_createLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::LineFactoryPrx::_iceI_getLoad(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<double>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_LineFactory_getLoad_name);
    outAsync->invoke(iceC_SIP_LineFactory_getLoad_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
SIP::LineFactoryPrx::_newInstance() const
{
    return ::IceInternal::createProxy<LineFactoryPrx>();
}
/// \endcond

const ::std::string&
SIP::LineFactoryPrx::ice_staticId()
{
    return LineFactory::ice_staticId();
}

/// \cond INTERNAL
void
SIP::StopFactoryPrx::_iceI_createStop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::StopPrx>>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_StopFactory_createStop_name);
    outAsync->invoke(iceC_SIP_StopFactory_createStop_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::StopFactoryPrx::_iceI_getLoad(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<double>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_StopFactory_getLoad_name);
    outAsync->invoke(iceC_SIP_StopFactory_getLoad_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
SIP::StopFactoryPrx::_newInstance() const
{
    return ::IceInternal::createProxy<StopFactoryPrx>();
}
/// \endcond

const ::std::string&
SIP::StopFactoryPrx::ice_staticId()
{
    return StopFactory::ice_staticId();
}

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_getTramStop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::TramStopPrx>>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_MPK_getTramStop_name);
    outAsync->invoke(iceC_SIP_MPK_getTramStop_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_registerDepo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<DepoPrx>& iceP_depo, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_MPK_registerDepo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_depo);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_unregisterDepo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<DepoPrx>& iceP_depo, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_MPK_unregisterDepo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_depo);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_getDepo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::DepoPrx>>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_MPK_getDepo_name);
    outAsync->invoke(iceC_SIP_MPK_getDepo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_getDepos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::DepoList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_MPK_getDepos_name);
    outAsync->invoke(iceC_SIP_MPK_getDepos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_getLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::LineList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_MPK_getLines_name);
    outAsync->invoke(iceC_SIP_MPK_getLines_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_registerLineFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<LineFactoryPrx>& iceP_lf, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_MPK_registerLineFactory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_lf);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_unregisterLineFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<LineFactoryPrx>& iceP_lf, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_MPK_unregisterLineFactory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_lf);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_registerStopFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<StopFactoryPrx>& iceP_lf, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_MPK_registerStopFactory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_lf);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::MPKPrx::_iceI_unregisterStopFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<StopFactoryPrx>& iceP_lf, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_MPK_unregisterStopFactory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_lf);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
SIP::MPKPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MPKPrx>();
}
/// \endcond

const ::std::string&
SIP::MPKPrx::ice_staticId()
{
    return MPK::ice_staticId();
}

/// \cond INTERNAL
void
SIP::DepoPrx::_iceI_TramOnline(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<TramPrx>& iceP_t, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Depo_TramOnline_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_t);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::DepoPrx::_iceI_TramOffline(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<TramPrx>& iceP_t, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Depo_TramOffline_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_t);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::DepoPrx::_iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_Depo_getName_name);
    outAsync->invoke(iceC_SIP_Depo_getName_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
SIP::DepoPrx::_newInstance() const
{
    return ::IceInternal::createProxy<DepoPrx>();
}
/// \endcond

const ::std::string&
SIP::DepoPrx::ice_staticId()
{
    return Depo::ice_staticId();
}

/// \cond INTERNAL
void
SIP::TramPrx::_iceI_getLocation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::TramStopPrx>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_Tram_getLocation_name);
    outAsync->invoke(iceC_SIP_Tram_getLocation_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramPrx::_iceI_getLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::LinePrx>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_Tram_getLine_name);
    outAsync->invoke(iceC_SIP_Tram_getLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramPrx::_iceI_setLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<LinePrx>& iceP_line, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Tram_setLine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_line);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramPrx::_iceI_getNextStops(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::StopList>>& outAsync, int iceP_howMany, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_Tram_getNextStops_name);
    outAsync->invoke(iceC_SIP_Tram_getNextStops_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_howMany);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramPrx::_iceI_RegisterPassenger(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<PassengerPrx>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Tram_RegisterPassenger_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramPrx::_iceI_UnregisterPassenger(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<PassengerPrx>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Tram_UnregisterPassenger_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::TramPrx::_iceI_getStockNumber(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_SIP_Tram_getStockNumber_name);
    outAsync->invoke(iceC_SIP_Tram_getStockNumber_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
SIP::TramPrx::_newInstance() const
{
    return ::IceInternal::createProxy<TramPrx>();
}
/// \endcond

const ::std::string&
SIP::TramPrx::ice_staticId()
{
    return Tram::ice_staticId();
}

/// \cond INTERNAL
void
SIP::PassengerPrx::_iceI_updateTramInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<TramPrx>& iceP_tram, const StopList& iceP_stops, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Passenger_updateTramInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_tram, iceP_stops);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
SIP::PassengerPrx::_iceI_updateStopInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<StopPrx>& iceP_stop, const TramList& iceP_trams, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_SIP_Passenger_updateStopInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stop, iceP_trams);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
SIP::PassengerPrx::_newInstance() const
{
    return ::IceInternal::createProxy<PassengerPrx>();
}
/// \endcond

const ::std::string&
SIP::PassengerPrx::ice_staticId()
{
    return Passenger::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_SIP_TramStop_getName_name = "getName";

const ::std::string iceC_SIP_TramStop_getNextTrams_name = "getNextTrams";

const ::std::string iceC_SIP_TramStop_RegisterPassenger_name = "RegisterPassenger";

const ::std::string iceC_SIP_TramStop_UnregisterPassenger_name = "UnregisterPassenger";

const ::std::string iceC_SIP_TramStop_UpdateTramInfo_name = "UpdateTramInfo";

const ::std::string iceC_SIP_Line_getTrams_name = "getTrams";

const ::std::string iceC_SIP_Line_getStops_name = "getStops";

const ::std::string iceC_SIP_Line_registerTram_name = "registerTram";

const ::std::string iceC_SIP_Line_unregisterTram_name = "unregisterTram";

const ::std::string iceC_SIP_Line_setStops_name = "setStops";

const ::std::string iceC_SIP_Line_getName_name = "getName";

const ::std::string iceC_SIP_LineFactory_createLine_name = "createLine";

const ::std::string iceC_SIP_LineFactory_getLoad_name = "getLoad";

const ::std::string iceC_SIP_StopFactory_createStop_name = "createStop";

const ::std::string iceC_SIP_StopFactory_getLoad_name = "getLoad";

const ::std::string iceC_SIP_MPK_getTramStop_name = "getTramStop";

const ::std::string iceC_SIP_MPK_registerDepo_name = "registerDepo";

const ::std::string iceC_SIP_MPK_unregisterDepo_name = "unregisterDepo";

const ::std::string iceC_SIP_MPK_getDepo_name = "getDepo";

const ::std::string iceC_SIP_MPK_getDepos_name = "getDepos";

const ::std::string iceC_SIP_MPK_getLines_name = "getLines";

const ::std::string iceC_SIP_MPK_registerLineFactory_name = "registerLineFactory";

const ::std::string iceC_SIP_MPK_unregisterLineFactory_name = "unregisterLineFactory";

const ::std::string iceC_SIP_MPK_registerStopFactory_name = "registerStopFactory";

const ::std::string iceC_SIP_MPK_unregisterStopFactory_name = "unregisterStopFactory";

const ::std::string iceC_SIP_Depo_TramOnline_name = "TramOnline";

const ::std::string iceC_SIP_Depo_TramOffline_name = "TramOffline";

const ::std::string iceC_SIP_Depo_getName_name = "getName";

const ::std::string iceC_SIP_Tram_getLocation_name = "getLocation";

const ::std::string iceC_SIP_Tram_getLine_name = "getLine";

const ::std::string iceC_SIP_Tram_setLine_name = "setLine";

const ::std::string iceC_SIP_Tram_getNextStops_name = "getNextStops";

const ::std::string iceC_SIP_Tram_RegisterPassenger_name = "RegisterPassenger";

const ::std::string iceC_SIP_Tram_UnregisterPassenger_name = "UnregisterPassenger";

const ::std::string iceC_SIP_Tram_getStockNumber_name = "getStockNumber";

const ::std::string iceC_SIP_Passenger_updateTramInfo_name = "updateTramInfo";

const ::std::string iceC_SIP_Passenger_updateStopInfo_name = "updateStopInfo";

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::SIP::upCast(TramStop* p) { return p; }

void
::IceProxy::SIP::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< TramStop>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new TramStop;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::SIP::TramStop::_iceI_begin_getName(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_TramStop_getName_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_TramStop_getName_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_TramStop_getName_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_TramStop_getName_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::SIP::TramStop::end_getName(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_TramStop_getName_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::TramStop::_iceI_begin_getNextTrams(::Ice::Int iceP_howMany, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_TramStop_getNextTrams_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_TramStop_getNextTrams_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_TramStop_getNextTrams_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_howMany);
        result->endWriteParams();
        result->invoke(iceC_SIP_TramStop_getNextTrams_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::TramList
IceProxy::SIP::TramStop::end_getNextTrams(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_TramStop_getNextTrams_name);
    ::SIP::TramList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::TramStop::_iceI_begin_RegisterPassenger(const ::SIP::PassengerPrx& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_TramStop_RegisterPassenger_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_TramStop_RegisterPassenger_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p);
        result->endWriteParams();
        result->invoke(iceC_SIP_TramStop_RegisterPassenger_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::TramStop::end_RegisterPassenger(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_TramStop_RegisterPassenger_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::TramStop::_iceI_begin_UnregisterPassenger(const ::SIP::PassengerPrx& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_TramStop_UnregisterPassenger_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_TramStop_UnregisterPassenger_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p);
        result->endWriteParams();
        result->invoke(iceC_SIP_TramStop_UnregisterPassenger_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::TramStop::end_UnregisterPassenger(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_TramStop_UnregisterPassenger_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::TramStop::_iceI_begin_UpdateTramInfo(const ::SIP::TramPrx& iceP_tram, const ::SIP::Time& iceP_time, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_TramStop_UpdateTramInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_TramStop_UpdateTramInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_tram);
        ostr->write(iceP_time);
        result->endWriteParams();
        result->invoke(iceC_SIP_TramStop_UpdateTramInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::TramStop::end_UpdateTramInfo(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_TramStop_UpdateTramInfo_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::SIP::TramStop::_newInstance() const
{
    return new TramStop;
}
/// \endcond

const ::std::string&
IceProxy::SIP::TramStop::ice_staticId()
{
    return ::SIP::TramStop::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::SIP::upCast(Line* p) { return p; }

void
::IceProxy::SIP::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Line>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Line;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::SIP::Line::_iceI_begin_getTrams(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_Line_getTrams_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Line_getTrams_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Line_getTrams_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_Line_getTrams_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::TramList
IceProxy::SIP::Line::end_getTrams(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_Line_getTrams_name);
    ::SIP::TramList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::Line::_iceI_begin_getStops(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_Line_getStops_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Line_getStops_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Line_getStops_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_Line_getStops_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::StopList
IceProxy::SIP::Line::end_getStops(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_Line_getStops_name);
    ::SIP::StopList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::Line::_iceI_begin_registerTram(const ::SIP::TramPrx& iceP_tram, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Line_registerTram_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Line_registerTram_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_tram);
        result->endWriteParams();
        result->invoke(iceC_SIP_Line_registerTram_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Line::end_registerTram(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Line_registerTram_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Line::_iceI_begin_unregisterTram(const ::SIP::TramPrx& iceP_tram, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Line_unregisterTram_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Line_unregisterTram_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_tram);
        result->endWriteParams();
        result->invoke(iceC_SIP_Line_unregisterTram_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Line::end_unregisterTram(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Line_unregisterTram_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Line::_iceI_begin_setStops(const ::SIP::StopList& iceP_sl, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Line_setStops_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Line_setStops_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_sl);
        result->endWriteParams();
        result->invoke(iceC_SIP_Line_setStops_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Line::end_setStops(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Line_setStops_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Line::_iceI_begin_getName(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_Line_getName_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Line_getName_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Line_getName_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_Line_getName_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::SIP::Line::end_getName(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_Line_getName_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::SIP::Line::_newInstance() const
{
    return new Line;
}
/// \endcond

const ::std::string&
IceProxy::SIP::Line::ice_staticId()
{
    return ::SIP::Line::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::SIP::upCast(LineFactory* p) { return p; }

void
::IceProxy::SIP::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< LineFactory>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new LineFactory;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::SIP::LineFactory::_iceI_begin_createLine(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_LineFactory_createLine_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_LineFactory_createLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_LineFactory_createLine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_SIP_LineFactory_createLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::LinePrx
IceProxy::SIP::LineFactory::end_createLine(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_LineFactory_createLine_name);
    ::SIP::LinePrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::LineFactory::_iceI_begin_getLoad(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_LineFactory_getLoad_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_LineFactory_getLoad_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_LineFactory_getLoad_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_LineFactory_getLoad_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Double
IceProxy::SIP::LineFactory::end_getLoad(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_LineFactory_getLoad_name);
    ::Ice::Double ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::SIP::LineFactory::_newInstance() const
{
    return new LineFactory;
}
/// \endcond

const ::std::string&
IceProxy::SIP::LineFactory::ice_staticId()
{
    return ::SIP::LineFactory::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::SIP::upCast(StopFactory* p) { return p; }

void
::IceProxy::SIP::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< StopFactory>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new StopFactory;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::SIP::StopFactory::_iceI_begin_createStop(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_StopFactory_createStop_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_StopFactory_createStop_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_StopFactory_createStop_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_SIP_StopFactory_createStop_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::StopPrx
IceProxy::SIP::StopFactory::end_createStop(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_StopFactory_createStop_name);
    ::SIP::StopPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::StopFactory::_iceI_begin_getLoad(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_StopFactory_getLoad_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_StopFactory_getLoad_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_StopFactory_getLoad_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_StopFactory_getLoad_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Double
IceProxy::SIP::StopFactory::end_getLoad(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_StopFactory_getLoad_name);
    ::Ice::Double ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::SIP::StopFactory::_newInstance() const
{
    return new StopFactory;
}
/// \endcond

const ::std::string&
IceProxy::SIP::StopFactory::ice_staticId()
{
    return ::SIP::StopFactory::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::SIP::upCast(MPK* p) { return p; }

void
::IceProxy::SIP::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MPK>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MPK;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_getTramStop(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_MPK_getTramStop_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_getTramStop_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_getTramStop_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_SIP_MPK_getTramStop_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::TramStopPrx
IceProxy::SIP::MPK::end_getTramStop(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_MPK_getTramStop_name);
    ::SIP::TramStopPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_registerDepo(const ::SIP::DepoPrx& iceP_depo, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_registerDepo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_registerDepo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_depo);
        result->endWriteParams();
        result->invoke(iceC_SIP_MPK_registerDepo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::MPK::end_registerDepo(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_MPK_registerDepo_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_unregisterDepo(const ::SIP::DepoPrx& iceP_depo, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_unregisterDepo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_unregisterDepo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_depo);
        result->endWriteParams();
        result->invoke(iceC_SIP_MPK_unregisterDepo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::MPK::end_unregisterDepo(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_MPK_unregisterDepo_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_getDepo(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_MPK_getDepo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_getDepo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_getDepo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_SIP_MPK_getDepo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::DepoPrx
IceProxy::SIP::MPK::end_getDepo(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_MPK_getDepo_name);
    ::SIP::DepoPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_getDepos(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_MPK_getDepos_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_getDepos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_getDepos_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_MPK_getDepos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::DepoList
IceProxy::SIP::MPK::end_getDepos(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_MPK_getDepos_name);
    ::SIP::DepoList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_getLines(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_MPK_getLines_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_getLines_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_getLines_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_MPK_getLines_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::LineList
IceProxy::SIP::MPK::end_getLines(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_MPK_getLines_name);
    ::SIP::LineList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_registerLineFactory(const ::SIP::LineFactoryPrx& iceP_lf, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_registerLineFactory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_registerLineFactory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_lf);
        result->endWriteParams();
        result->invoke(iceC_SIP_MPK_registerLineFactory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::MPK::end_registerLineFactory(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_MPK_registerLineFactory_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_unregisterLineFactory(const ::SIP::LineFactoryPrx& iceP_lf, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_unregisterLineFactory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_unregisterLineFactory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_lf);
        result->endWriteParams();
        result->invoke(iceC_SIP_MPK_unregisterLineFactory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::MPK::end_unregisterLineFactory(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_MPK_unregisterLineFactory_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_registerStopFactory(const ::SIP::StopFactoryPrx& iceP_lf, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_registerStopFactory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_registerStopFactory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_lf);
        result->endWriteParams();
        result->invoke(iceC_SIP_MPK_registerStopFactory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::MPK::end_registerStopFactory(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_MPK_registerStopFactory_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::MPK::_iceI_begin_unregisterStopFactory(const ::SIP::StopFactoryPrx& iceP_lf, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_MPK_unregisterStopFactory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_MPK_unregisterStopFactory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_lf);
        result->endWriteParams();
        result->invoke(iceC_SIP_MPK_unregisterStopFactory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::MPK::end_unregisterStopFactory(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_MPK_unregisterStopFactory_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::SIP::MPK::_newInstance() const
{
    return new MPK;
}
/// \endcond

const ::std::string&
IceProxy::SIP::MPK::ice_staticId()
{
    return ::SIP::MPK::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::SIP::upCast(Depo* p) { return p; }

void
::IceProxy::SIP::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Depo>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Depo;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::SIP::Depo::_iceI_begin_TramOnline(const ::SIP::TramPrx& iceP_t, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Depo_TramOnline_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Depo_TramOnline_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_t);
        result->endWriteParams();
        result->invoke(iceC_SIP_Depo_TramOnline_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Depo::end_TramOnline(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Depo_TramOnline_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Depo::_iceI_begin_TramOffline(const ::SIP::TramPrx& iceP_t, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Depo_TramOffline_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Depo_TramOffline_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_t);
        result->endWriteParams();
        result->invoke(iceC_SIP_Depo_TramOffline_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Depo::end_TramOffline(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Depo_TramOffline_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Depo::_iceI_begin_getName(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_Depo_getName_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Depo_getName_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Depo_getName_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_Depo_getName_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::SIP::Depo::end_getName(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_Depo_getName_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::SIP::Depo::_newInstance() const
{
    return new Depo;
}
/// \endcond

const ::std::string&
IceProxy::SIP::Depo::ice_staticId()
{
    return ::SIP::Depo::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::SIP::upCast(Tram* p) { return p; }

void
::IceProxy::SIP::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Tram>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Tram;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::SIP::Tram::_iceI_begin_getLocation(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_Tram_getLocation_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Tram_getLocation_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Tram_getLocation_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_Tram_getLocation_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::TramStopPrx
IceProxy::SIP::Tram::end_getLocation(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_Tram_getLocation_name);
    ::SIP::TramStopPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::Tram::_iceI_begin_getLine(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_Tram_getLine_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Tram_getLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Tram_getLine_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_Tram_getLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::LinePrx
IceProxy::SIP::Tram::end_getLine(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_Tram_getLine_name);
    ::SIP::LinePrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::Tram::_iceI_begin_setLine(const ::SIP::LinePrx& iceP_line, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Tram_setLine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Tram_setLine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_line);
        result->endWriteParams();
        result->invoke(iceC_SIP_Tram_setLine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Tram::end_setLine(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Tram_setLine_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Tram::_iceI_begin_getNextStops(::Ice::Int iceP_howMany, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_Tram_getNextStops_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Tram_getNextStops_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Tram_getNextStops_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_howMany);
        result->endWriteParams();
        result->invoke(iceC_SIP_Tram_getNextStops_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::SIP::StopList
IceProxy::SIP::Tram::end_getNextStops(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_Tram_getNextStops_name);
    ::SIP::StopList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::SIP::Tram::_iceI_begin_RegisterPassenger(const ::SIP::PassengerPrx& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Tram_RegisterPassenger_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Tram_RegisterPassenger_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p);
        result->endWriteParams();
        result->invoke(iceC_SIP_Tram_RegisterPassenger_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Tram::end_RegisterPassenger(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Tram_RegisterPassenger_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Tram::_iceI_begin_UnregisterPassenger(const ::SIP::PassengerPrx& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Tram_UnregisterPassenger_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Tram_UnregisterPassenger_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p);
        result->endWriteParams();
        result->invoke(iceC_SIP_Tram_UnregisterPassenger_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Tram::end_UnregisterPassenger(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Tram_UnregisterPassenger_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Tram::_iceI_begin_getStockNumber(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_SIP_Tram_getStockNumber_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Tram_getStockNumber_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Tram_getStockNumber_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_SIP_Tram_getStockNumber_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::SIP::Tram::end_getStockNumber(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_SIP_Tram_getStockNumber_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::SIP::Tram::_newInstance() const
{
    return new Tram;
}
/// \endcond

const ::std::string&
IceProxy::SIP::Tram::ice_staticId()
{
    return ::SIP::Tram::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::SIP::upCast(Passenger* p) { return p; }

void
::IceProxy::SIP::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Passenger>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Passenger;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::SIP::Passenger::_iceI_begin_updateTramInfo(const ::SIP::TramPrx& iceP_tram, const ::SIP::StopList& iceP_stops, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Passenger_updateTramInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Passenger_updateTramInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_tram);
        ostr->write(iceP_stops);
        result->endWriteParams();
        result->invoke(iceC_SIP_Passenger_updateTramInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Passenger::end_updateTramInfo(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Passenger_updateTramInfo_name);
}

::Ice::AsyncResultPtr
IceProxy::SIP::Passenger::_iceI_begin_updateStopInfo(const ::SIP::StopPrx& iceP_stop, const ::SIP::TramList& iceP_trams, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_SIP_Passenger_updateStopInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_SIP_Passenger_updateStopInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stop);
        ostr->write(iceP_trams);
        result->endWriteParams();
        result->invoke(iceC_SIP_Passenger_updateStopInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::SIP::Passenger::end_updateStopInfo(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_SIP_Passenger_updateStopInfo_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::SIP::Passenger::_newInstance() const
{
    return new Passenger;
}
/// \endcond

const ::std::string&
IceProxy::SIP::Passenger::ice_staticId()
{
    return ::SIP::Passenger::ice_staticId();
}

SIP::TramStop::~TramStop()
{
}

/// \cond INTERNAL
::Ice::Object* SIP::upCast(TramStop* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_SIP_TramStop_ids[2] =
{
    "::Ice::Object",
    "::SIP::TramStop"
};

}

bool
SIP::TramStop::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_TramStop_ids, iceC_SIP_TramStop_ids + 2, s);
}

::std::vector< ::std::string>
SIP::TramStop::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_SIP_TramStop_ids[0], &iceC_SIP_TramStop_ids[2]);
}

const ::std::string&
SIP::TramStop::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::TramStop::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SIP::TramStop";
    return typeId;
#else
    return iceC_SIP_TramStop_ids[1];
#endif
}

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_getNextTrams(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_howMany;
    istr->read(iceP_howMany);
    inS.endReadParams();
    TramList ret = this->getNextTrams(iceP_howMany, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_RegisterPassenger(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PassengerPrx iceP_p;
    istr->read(iceP_p);
    inS.endReadParams();
    this->RegisterPassenger(iceP_p, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_UnregisterPassenger(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PassengerPrx iceP_p;
    istr->read(iceP_p);
    inS.endReadParams();
    this->UnregisterPassenger(iceP_p, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::TramStop::_iceD_UpdateTramInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    TramPrx iceP_tram;
    Time iceP_time;
    istr->read(iceP_tram);
    istr->read(iceP_time);
    inS.endReadParams();
    this->UpdateTramInfo(iceP_tram, iceP_time, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_SIP_TramStop_all[] =
{
    "RegisterPassenger",
    "UnregisterPassenger",
    "UpdateTramInfo",
    "getName",
    "getNextTrams",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
SIP::TramStop::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_TramStop_all, iceC_SIP_TramStop_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_TramStop_all)
    {
        case 0:
        {
            return _iceD_RegisterPassenger(in, current);
        }
        case 1:
        {
            return _iceD_UnregisterPassenger(in, current);
        }
        case 2:
        {
            return _iceD_UpdateTramInfo(in, current);
        }
        case 3:
        {
            return _iceD_getName(in, current);
        }
        case 4:
        {
            return _iceD_getNextTrams(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
SIP::TramStop::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< TramStop, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
SIP::TramStop::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< TramStop, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
SIP::_icePatchObjectPtr(TramStopPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = TramStopPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(TramStop::ice_staticId(), v);
    }
}
/// \endcond

SIP::Line::~Line()
{
}

/// \cond INTERNAL
::Ice::Object* SIP::upCast(Line* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_SIP_Line_ids[2] =
{
    "::Ice::Object",
    "::SIP::Line"
};

}

bool
SIP::Line::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_Line_ids, iceC_SIP_Line_ids + 2, s);
}

::std::vector< ::std::string>
SIP::Line::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_SIP_Line_ids[0], &iceC_SIP_Line_ids[2]);
}

const ::std::string&
SIP::Line::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::Line::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SIP::Line";
    return typeId;
#else
    return iceC_SIP_Line_ids[1];
#endif
}

/// \cond INTERNAL
bool
SIP::Line::_iceD_getTrams(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    TramList ret = this->getTrams(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_getStops(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StopList ret = this->getStops(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_registerTram(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    TramPrx iceP_tram;
    istr->read(iceP_tram);
    inS.endReadParams();
    this->registerTram(iceP_tram, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_unregisterTram(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    TramPrx iceP_tram;
    istr->read(iceP_tram);
    inS.endReadParams();
    this->unregisterTram(iceP_tram, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_setStops(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StopList iceP_sl;
    istr->read(iceP_sl);
    inS.endReadParams();
    this->setStops(iceP_sl, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Line::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_SIP_Line_all[] =
{
    "getName",
    "getStops",
    "getTrams",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "registerTram",
    "setStops",
    "unregisterTram"
};

}

/// \cond INTERNAL
bool
SIP::Line::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_Line_all, iceC_SIP_Line_all + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_Line_all)
    {
        case 0:
        {
            return _iceD_getName(in, current);
        }
        case 1:
        {
            return _iceD_getStops(in, current);
        }
        case 2:
        {
            return _iceD_getTrams(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_registerTram(in, current);
        }
        case 8:
        {
            return _iceD_setStops(in, current);
        }
        case 9:
        {
            return _iceD_unregisterTram(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
SIP::Line::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Line, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
SIP::Line::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Line, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
SIP::_icePatchObjectPtr(LinePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = LinePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Line::ice_staticId(), v);
    }
}
/// \endcond

SIP::LineFactory::~LineFactory()
{
}

/// \cond INTERNAL
::Ice::Object* SIP::upCast(LineFactory* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_SIP_LineFactory_ids[2] =
{
    "::Ice::Object",
    "::SIP::LineFactory"
};

}

bool
SIP::LineFactory::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_LineFactory_ids, iceC_SIP_LineFactory_ids + 2, s);
}

::std::vector< ::std::string>
SIP::LineFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_SIP_LineFactory_ids[0], &iceC_SIP_LineFactory_ids[2]);
}

const ::std::string&
SIP::LineFactory::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::LineFactory::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SIP::LineFactory";
    return typeId;
#else
    return iceC_SIP_LineFactory_ids[1];
#endif
}

/// \cond INTERNAL
bool
SIP::LineFactory::_iceD_createLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    LinePrx ret = this->createLine(iceP_name, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::LineFactory::_iceD_getLoad(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Double ret = this->getLoad(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_SIP_LineFactory_all[] =
{
    "createLine",
    "getLoad",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
SIP::LineFactory::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_LineFactory_all, iceC_SIP_LineFactory_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_LineFactory_all)
    {
        case 0:
        {
            return _iceD_createLine(in, current);
        }
        case 1:
        {
            return _iceD_getLoad(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
SIP::LineFactory::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< LineFactory, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
SIP::LineFactory::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< LineFactory, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
SIP::_icePatchObjectPtr(LineFactoryPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = LineFactoryPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(LineFactory::ice_staticId(), v);
    }
}
/// \endcond

SIP::StopFactory::~StopFactory()
{
}

/// \cond INTERNAL
::Ice::Object* SIP::upCast(StopFactory* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_SIP_StopFactory_ids[2] =
{
    "::Ice::Object",
    "::SIP::StopFactory"
};

}

bool
SIP::StopFactory::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_StopFactory_ids, iceC_SIP_StopFactory_ids + 2, s);
}

::std::vector< ::std::string>
SIP::StopFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_SIP_StopFactory_ids[0], &iceC_SIP_StopFactory_ids[2]);
}

const ::std::string&
SIP::StopFactory::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::StopFactory::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SIP::StopFactory";
    return typeId;
#else
    return iceC_SIP_StopFactory_ids[1];
#endif
}

/// \cond INTERNAL
bool
SIP::StopFactory::_iceD_createStop(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    StopPrx ret = this->createStop(iceP_name, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::StopFactory::_iceD_getLoad(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Double ret = this->getLoad(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_SIP_StopFactory_all[] =
{
    "createStop",
    "getLoad",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
SIP::StopFactory::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_StopFactory_all, iceC_SIP_StopFactory_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_StopFactory_all)
    {
        case 0:
        {
            return _iceD_createStop(in, current);
        }
        case 1:
        {
            return _iceD_getLoad(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
SIP::StopFactory::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< StopFactory, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
SIP::StopFactory::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< StopFactory, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
SIP::_icePatchObjectPtr(StopFactoryPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = StopFactoryPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(StopFactory::ice_staticId(), v);
    }
}
/// \endcond

SIP::MPK::~MPK()
{
}

/// \cond INTERNAL
::Ice::Object* SIP::upCast(MPK* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_SIP_MPK_ids[2] =
{
    "::Ice::Object",
    "::SIP::MPK"
};

}

bool
SIP::MPK::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_MPK_ids, iceC_SIP_MPK_ids + 2, s);
}

::std::vector< ::std::string>
SIP::MPK::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_SIP_MPK_ids[0], &iceC_SIP_MPK_ids[2]);
}

const ::std::string&
SIP::MPK::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::MPK::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SIP::MPK";
    return typeId;
#else
    return iceC_SIP_MPK_ids[1];
#endif
}

/// \cond INTERNAL
bool
SIP::MPK::_iceD_getTramStop(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    TramStopPrx ret = this->getTramStop(iceP_name, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_registerDepo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    DepoPrx iceP_depo;
    istr->read(iceP_depo);
    inS.endReadParams();
    this->registerDepo(iceP_depo, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_unregisterDepo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    DepoPrx iceP_depo;
    istr->read(iceP_depo);
    inS.endReadParams();
    this->unregisterDepo(iceP_depo, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_getDepo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    DepoPrx ret = this->getDepo(iceP_name, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_getDepos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    DepoList ret = this->getDepos(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_getLines(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    LineList ret = this->getLines(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_registerLineFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LineFactoryPrx iceP_lf;
    istr->read(iceP_lf);
    inS.endReadParams();
    this->registerLineFactory(iceP_lf, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_unregisterLineFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LineFactoryPrx iceP_lf;
    istr->read(iceP_lf);
    inS.endReadParams();
    this->unregisterLineFactory(iceP_lf, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_registerStopFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StopFactoryPrx iceP_lf;
    istr->read(iceP_lf);
    inS.endReadParams();
    this->registerStopFactory(iceP_lf, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::MPK::_iceD_unregisterStopFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StopFactoryPrx iceP_lf;
    istr->read(iceP_lf);
    inS.endReadParams();
    this->unregisterStopFactory(iceP_lf, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_SIP_MPK_all[] =
{
    "getDepo",
    "getDepos",
    "getLines",
    "getTramStop",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "registerDepo",
    "registerLineFactory",
    "registerStopFactory",
    "unregisterDepo",
    "unregisterLineFactory",
    "unregisterStopFactory"
};

}

/// \cond INTERNAL
bool
SIP::MPK::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_MPK_all, iceC_SIP_MPK_all + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_MPK_all)
    {
        case 0:
        {
            return _iceD_getDepo(in, current);
        }
        case 1:
        {
            return _iceD_getDepos(in, current);
        }
        case 2:
        {
            return _iceD_getLines(in, current);
        }
        case 3:
        {
            return _iceD_getTramStop(in, current);
        }
        case 4:
        {
            return _iceD_ice_id(in, current);
        }
        case 5:
        {
            return _iceD_ice_ids(in, current);
        }
        case 6:
        {
            return _iceD_ice_isA(in, current);
        }
        case 7:
        {
            return _iceD_ice_ping(in, current);
        }
        case 8:
        {
            return _iceD_registerDepo(in, current);
        }
        case 9:
        {
            return _iceD_registerLineFactory(in, current);
        }
        case 10:
        {
            return _iceD_registerStopFactory(in, current);
        }
        case 11:
        {
            return _iceD_unregisterDepo(in, current);
        }
        case 12:
        {
            return _iceD_unregisterLineFactory(in, current);
        }
        case 13:
        {
            return _iceD_unregisterStopFactory(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
SIP::MPK::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MPK, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
SIP::MPK::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MPK, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
SIP::_icePatchObjectPtr(MPKPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MPKPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MPK::ice_staticId(), v);
    }
}
/// \endcond

SIP::Depo::~Depo()
{
}

/// \cond INTERNAL
::Ice::Object* SIP::upCast(Depo* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_SIP_Depo_ids[2] =
{
    "::Ice::Object",
    "::SIP::Depo"
};

}

bool
SIP::Depo::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_Depo_ids, iceC_SIP_Depo_ids + 2, s);
}

::std::vector< ::std::string>
SIP::Depo::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_SIP_Depo_ids[0], &iceC_SIP_Depo_ids[2]);
}

const ::std::string&
SIP::Depo::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::Depo::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SIP::Depo";
    return typeId;
#else
    return iceC_SIP_Depo_ids[1];
#endif
}

/// \cond INTERNAL
bool
SIP::Depo::_iceD_TramOnline(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    TramPrx iceP_t;
    istr->read(iceP_t);
    inS.endReadParams();
    this->TramOnline(iceP_t, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Depo::_iceD_TramOffline(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    TramPrx iceP_t;
    istr->read(iceP_t);
    inS.endReadParams();
    this->TramOffline(iceP_t, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Depo::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_SIP_Depo_all[] =
{
    "TramOffline",
    "TramOnline",
    "getName",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
SIP::Depo::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_Depo_all, iceC_SIP_Depo_all + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_Depo_all)
    {
        case 0:
        {
            return _iceD_TramOffline(in, current);
        }
        case 1:
        {
            return _iceD_TramOnline(in, current);
        }
        case 2:
        {
            return _iceD_getName(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
SIP::Depo::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Depo, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
SIP::Depo::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Depo, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
SIP::_icePatchObjectPtr(DepoPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = DepoPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Depo::ice_staticId(), v);
    }
}
/// \endcond

SIP::Tram::~Tram()
{
}

/// \cond INTERNAL
::Ice::Object* SIP::upCast(Tram* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_SIP_Tram_ids[2] =
{
    "::Ice::Object",
    "::SIP::Tram"
};

}

bool
SIP::Tram::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_Tram_ids, iceC_SIP_Tram_ids + 2, s);
}

::std::vector< ::std::string>
SIP::Tram::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_SIP_Tram_ids[0], &iceC_SIP_Tram_ids[2]);
}

const ::std::string&
SIP::Tram::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::Tram::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SIP::Tram";
    return typeId;
#else
    return iceC_SIP_Tram_ids[1];
#endif
}

/// \cond INTERNAL
bool
SIP::Tram::_iceD_getLocation(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    TramStopPrx ret = this->getLocation(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_getLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    LinePrx ret = this->getLine(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_setLine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LinePrx iceP_line;
    istr->read(iceP_line);
    inS.endReadParams();
    this->setLine(iceP_line, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_getNextStops(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_howMany;
    istr->read(iceP_howMany);
    inS.endReadParams();
    StopList ret = this->getNextStops(iceP_howMany, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_RegisterPassenger(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PassengerPrx iceP_p;
    istr->read(iceP_p);
    inS.endReadParams();
    this->RegisterPassenger(iceP_p, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_UnregisterPassenger(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PassengerPrx iceP_p;
    istr->read(iceP_p);
    inS.endReadParams();
    this->UnregisterPassenger(iceP_p, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Tram::_iceD_getStockNumber(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getStockNumber(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_SIP_Tram_all[] =
{
    "RegisterPassenger",
    "UnregisterPassenger",
    "getLine",
    "getLocation",
    "getNextStops",
    "getStockNumber",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setLine"
};

}

/// \cond INTERNAL
bool
SIP::Tram::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_Tram_all, iceC_SIP_Tram_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_Tram_all)
    {
        case 0:
        {
            return _iceD_RegisterPassenger(in, current);
        }
        case 1:
        {
            return _iceD_UnregisterPassenger(in, current);
        }
        case 2:
        {
            return _iceD_getLine(in, current);
        }
        case 3:
        {
            return _iceD_getLocation(in, current);
        }
        case 4:
        {
            return _iceD_getNextStops(in, current);
        }
        case 5:
        {
            return _iceD_getStockNumber(in, current);
        }
        case 6:
        {
            return _iceD_ice_id(in, current);
        }
        case 7:
        {
            return _iceD_ice_ids(in, current);
        }
        case 8:
        {
            return _iceD_ice_isA(in, current);
        }
        case 9:
        {
            return _iceD_ice_ping(in, current);
        }
        case 10:
        {
            return _iceD_setLine(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
SIP::Tram::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Tram, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
SIP::Tram::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Tram, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
SIP::_icePatchObjectPtr(TramPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = TramPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Tram::ice_staticId(), v);
    }
}
/// \endcond

SIP::Passenger::~Passenger()
{
}

/// \cond INTERNAL
::Ice::Object* SIP::upCast(Passenger* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_SIP_Passenger_ids[2] =
{
    "::Ice::Object",
    "::SIP::Passenger"
};

}

bool
SIP::Passenger::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_SIP_Passenger_ids, iceC_SIP_Passenger_ids + 2, s);
}

::std::vector< ::std::string>
SIP::Passenger::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_SIP_Passenger_ids[0], &iceC_SIP_Passenger_ids[2]);
}

const ::std::string&
SIP::Passenger::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
SIP::Passenger::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SIP::Passenger";
    return typeId;
#else
    return iceC_SIP_Passenger_ids[1];
#endif
}

/// \cond INTERNAL
bool
SIP::Passenger::_iceD_updateTramInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    TramPrx iceP_tram;
    StopList iceP_stops;
    istr->read(iceP_tram);
    istr->read(iceP_stops);
    inS.endReadParams();
    this->updateTramInfo(iceP_tram, iceP_stops, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
SIP::Passenger::_iceD_updateStopInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StopPrx iceP_stop;
    TramList iceP_trams;
    istr->read(iceP_stop);
    istr->read(iceP_trams);
    inS.endReadParams();
    this->updateStopInfo(iceP_stop, iceP_trams, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_SIP_Passenger_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "updateStopInfo",
    "updateTramInfo"
};

}

/// \cond INTERNAL
bool
SIP::Passenger::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_SIP_Passenger_all, iceC_SIP_Passenger_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_SIP_Passenger_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_updateStopInfo(in, current);
        }
        case 5:
        {
            return _iceD_updateTramInfo(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
SIP::Passenger::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Passenger, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
SIP::Passenger::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Passenger, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
SIP::_icePatchObjectPtr(PassengerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PassengerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Passenger::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
