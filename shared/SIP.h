//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `SIP.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __SIP_h__
#define __SIP_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace SIP
{

class Tram;
class TramPrx;
class TramStop;
class TramStopPrx;
class Depo;
class DepoPrx;
class Passenger;
class PassengerPrx;
class Stop;
class StopPrx;
class Line;
class LinePrx;
class LineFactory;
class LineFactoryPrx;
class StopFactory;
class StopFactoryPrx;
class MPK;
class MPKPrx;

}

namespace SIP
{

struct Time
{
    int hour;
    int minute;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(hour, minute);
    }
};

struct StopInfo
{
    ::SIP::Time time;
    ::std::shared_ptr<::SIP::TramStopPrx> stop;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::SIP::Time&, const ::std::shared_ptr<::SIP::TramStopPrx>&> ice_tuple() const
    {
        return std::tie(time, stop);
    }
};

using StopList = ::std::vector<StopInfo>;

struct TramInfo
{
    ::SIP::Time time;
    ::std::shared_ptr<::SIP::TramPrx> tram;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::SIP::Time&, const ::std::shared_ptr<::SIP::TramPrx>&> ice_tuple() const
    {
        return std::tie(time, tram);
    }
};

using TramList = ::std::vector<TramInfo>;

struct DepoInfo
{
    ::std::string name;
    ::std::shared_ptr<::SIP::DepoPrx> stop;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::SIP::DepoPrx>&> ice_tuple() const
    {
        return std::tie(name, stop);
    }
};

using DepoList = ::std::vector<DepoInfo>;

using LineList = ::std::vector<::std::shared_ptr<LinePrx>>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace SIP
{

class TramStop : public virtual ::Ice::Object
{
public:

    using ProxyType = TramStopPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::string getName(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TramList getNextTrams(int howMany, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getNextTrams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RegisterPassenger(::std::shared_ptr<PassengerPrx> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RegisterPassenger(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UnregisterPassenger(::std::shared_ptr<PassengerPrx> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UnregisterPassenger(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateTramInfo(::std::shared_ptr<TramPrx> tram, Time time, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateTramInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Line : public virtual ::Ice::Object
{
public:

    using ProxyType = LinePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual TramList getTrams(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTrams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StopList getStops(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getStops(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerTram(::std::shared_ptr<TramPrx> tram, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerTram(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterTram(::std::shared_ptr<TramPrx> tram, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterTram(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setStops(StopList sl, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setStops(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getName(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class LineFactory : public virtual ::Ice::Object
{
public:

    using ProxyType = LineFactoryPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<LinePrx> createLine(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_createLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual double getLoad(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getLoad(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class StopFactory : public virtual ::Ice::Object
{
public:

    using ProxyType = StopFactoryPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<StopPrx> createStop(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_createStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual double getLoad(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getLoad(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class MPK : public virtual ::Ice::Object
{
public:

    using ProxyType = MPKPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<TramStopPrx> getTramStop(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTramStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerDepo(::std::shared_ptr<DepoPrx> depo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerDepo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterDepo(::std::shared_ptr<DepoPrx> depo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterDepo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<DepoPrx> getDepo(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getDepo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DepoList getDepos(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getDepos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LineList getLines(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerLineFactory(::std::shared_ptr<LineFactoryPrx> lf, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerLineFactory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterLineFactory(::std::shared_ptr<LineFactoryPrx> lf, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterLineFactory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerStopFactory(::std::shared_ptr<StopFactoryPrx> lf, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerStopFactory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterStopFactory(::std::shared_ptr<StopFactoryPrx> lf, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterStopFactory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Depo : public virtual ::Ice::Object
{
public:

    using ProxyType = DepoPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void TramOnline(::std::shared_ptr<TramPrx> t, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_TramOnline(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void TramOffline(::std::shared_ptr<TramPrx> t, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_TramOffline(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getName(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Tram : public virtual ::Ice::Object
{
public:

    using ProxyType = TramPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<TramStopPrx> getLocation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getLocation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<LinePrx> getLine(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setLine(::std::shared_ptr<LinePrx> line, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StopList getNextStops(int howMany, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getNextStops(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RegisterPassenger(::std::shared_ptr<PassengerPrx> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RegisterPassenger(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UnregisterPassenger(::std::shared_ptr<PassengerPrx> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UnregisterPassenger(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getStockNumber(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getStockNumber(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Passenger : public virtual ::Ice::Object
{
public:

    using ProxyType = PassengerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void updateTramInfo(::std::shared_ptr<TramPrx> tram, StopList stops, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_updateTramInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void updateStopInfo(::std::shared_ptr<StopPrx> stop, TramList trams, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_updateStopInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace SIP
{

class TramStopPrx : public virtual ::Ice::Proxy<TramStopPrx, ::Ice::ObjectPrx>
{
public:

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &TramStopPrx::_iceI_getName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &TramStopPrx::_iceI_getName, context);
    }

    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramStopPrx::_iceI_getName, context);
    }

    /// \cond INTERNAL
    void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    TramList getNextTrams(int howMany, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::SIP::TramList>(true, this, &TramStopPrx::_iceI_getNextTrams, howMany, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNextTramsAsync(int howMany, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::SIP::TramList>>().get_future())
    {
        return _makePromiseOutgoing<::SIP::TramList, P>(false, this, &TramStopPrx::_iceI_getNextTrams, howMany, context);
    }

    ::std::function<void()>
    getNextTramsAsync(int howMany,
                      ::std::function<void(::SIP::TramList)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::SIP::TramList>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramStopPrx::_iceI_getNextTrams, howMany, context);
    }

    /// \cond INTERNAL
    void _iceI_getNextTrams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::TramList>>&, int, const ::Ice::Context&);
    /// \endcond

    void RegisterPassenger(const ::std::shared_ptr<PassengerPrx>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TramStopPrx::_iceI_RegisterPassenger, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RegisterPassengerAsync(const ::std::shared_ptr<PassengerPrx>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TramStopPrx::_iceI_RegisterPassenger, p, context);
    }

    ::std::function<void()>
    RegisterPassengerAsync(const ::std::shared_ptr<PassengerPrx>& p,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramStopPrx::_iceI_RegisterPassenger, p, context);
    }

    /// \cond INTERNAL
    void _iceI_RegisterPassenger(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<PassengerPrx>&, const ::Ice::Context&);
    /// \endcond

    void UnregisterPassenger(const ::std::shared_ptr<PassengerPrx>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TramStopPrx::_iceI_UnregisterPassenger, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UnregisterPassengerAsync(const ::std::shared_ptr<PassengerPrx>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TramStopPrx::_iceI_UnregisterPassenger, p, context);
    }

    ::std::function<void()>
    UnregisterPassengerAsync(const ::std::shared_ptr<PassengerPrx>& p,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramStopPrx::_iceI_UnregisterPassenger, p, context);
    }

    /// \cond INTERNAL
    void _iceI_UnregisterPassenger(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<PassengerPrx>&, const ::Ice::Context&);
    /// \endcond

    void UpdateTramInfo(const ::std::shared_ptr<TramPrx>& tram, const Time& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TramStopPrx::_iceI_UpdateTramInfo, tram, time, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateTramInfoAsync(const ::std::shared_ptr<TramPrx>& tram, const Time& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TramStopPrx::_iceI_UpdateTramInfo, tram, time, context);
    }

    ::std::function<void()>
    UpdateTramInfoAsync(const ::std::shared_ptr<TramPrx>& tram, const Time& time,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramStopPrx::_iceI_UpdateTramInfo, tram, time, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateTramInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const Time&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TramStopPrx() = default;
    friend ::std::shared_ptr<TramStopPrx> IceInternal::createProxy<TramStopPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class LinePrx : public virtual ::Ice::Proxy<LinePrx, ::Ice::ObjectPrx>
{
public:

    TramList getTrams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::SIP::TramList>(true, this, &LinePrx::_iceI_getTrams, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getTramsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::SIP::TramList>>().get_future())
    {
        return _makePromiseOutgoing<::SIP::TramList, P>(false, this, &LinePrx::_iceI_getTrams, context);
    }

    ::std::function<void()>
    getTramsAsync(::std::function<void(::SIP::TramList)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::SIP::TramList>(std::move(response), std::move(ex), std::move(sent), this, &SIP::LinePrx::_iceI_getTrams, context);
    }

    /// \cond INTERNAL
    void _iceI_getTrams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::TramList>>&, const ::Ice::Context&);
    /// \endcond

    StopList getStops(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::SIP::StopList>(true, this, &LinePrx::_iceI_getStops, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStopsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::SIP::StopList>>().get_future())
    {
        return _makePromiseOutgoing<::SIP::StopList, P>(false, this, &LinePrx::_iceI_getStops, context);
    }

    ::std::function<void()>
    getStopsAsync(::std::function<void(::SIP::StopList)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::SIP::StopList>(std::move(response), std::move(ex), std::move(sent), this, &SIP::LinePrx::_iceI_getStops, context);
    }

    /// \cond INTERNAL
    void _iceI_getStops(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::StopList>>&, const ::Ice::Context&);
    /// \endcond

    void registerTram(const ::std::shared_ptr<TramPrx>& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LinePrx::_iceI_registerTram, tram, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerTramAsync(const ::std::shared_ptr<TramPrx>& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LinePrx::_iceI_registerTram, tram, context);
    }

    ::std::function<void()>
    registerTramAsync(const ::std::shared_ptr<TramPrx>& tram,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::LinePrx::_iceI_registerTram, tram, context);
    }

    /// \cond INTERNAL
    void _iceI_registerTram(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const ::Ice::Context&);
    /// \endcond

    void unregisterTram(const ::std::shared_ptr<TramPrx>& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LinePrx::_iceI_unregisterTram, tram, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unregisterTramAsync(const ::std::shared_ptr<TramPrx>& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LinePrx::_iceI_unregisterTram, tram, context);
    }

    ::std::function<void()>
    unregisterTramAsync(const ::std::shared_ptr<TramPrx>& tram,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::LinePrx::_iceI_unregisterTram, tram, context);
    }

    /// \cond INTERNAL
    void _iceI_unregisterTram(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const ::Ice::Context&);
    /// \endcond

    void setStops(const StopList& sl, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LinePrx::_iceI_setStops, sl, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setStopsAsync(const StopList& sl, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LinePrx::_iceI_setStops, sl, context);
    }

    ::std::function<void()>
    setStopsAsync(const StopList& sl,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::LinePrx::_iceI_setStops, sl, context);
    }

    /// \cond INTERNAL
    void _iceI_setStops(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const StopList&, const ::Ice::Context&);
    /// \endcond

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &LinePrx::_iceI_getName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &LinePrx::_iceI_getName, context);
    }

    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &SIP::LinePrx::_iceI_getName, context);
    }

    /// \cond INTERNAL
    void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LinePrx() = default;
    friend ::std::shared_ptr<LinePrx> IceInternal::createProxy<LinePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class LineFactoryPrx : public virtual ::Ice::Proxy<LineFactoryPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<LinePrx> createLine(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::LinePrx>>(true, this, &LineFactoryPrx::_iceI_createLine, name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto createLineAsync(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::SIP::LinePrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::LinePrx>, P>(false, this, &LineFactoryPrx::_iceI_createLine, name, context);
    }

    ::std::function<void()>
    createLineAsync(const ::std::string& name,
                    ::std::function<void(::std::shared_ptr<::SIP::LinePrx>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::SIP::LinePrx>>(std::move(response), std::move(ex), std::move(sent), this, &SIP::LineFactoryPrx::_iceI_createLine, name, context);
    }

    /// \cond INTERNAL
    void _iceI_createLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::LinePrx>>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    double getLoad(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<double>(true, this, &LineFactoryPrx::_iceI_getLoad, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getLoadAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<double>>().get_future())
    {
        return _makePromiseOutgoing<double, P>(false, this, &LineFactoryPrx::_iceI_getLoad, context);
    }

    ::std::function<void()>
    getLoadAsync(::std::function<void(double)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<double>(std::move(response), std::move(ex), std::move(sent), this, &SIP::LineFactoryPrx::_iceI_getLoad, context);
    }

    /// \cond INTERNAL
    void _iceI_getLoad(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<double>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LineFactoryPrx() = default;
    friend ::std::shared_ptr<LineFactoryPrx> IceInternal::createProxy<LineFactoryPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class StopFactoryPrx : public virtual ::Ice::Proxy<StopFactoryPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<StopPrx> createStop(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::StopPrx>>(true, this, &StopFactoryPrx::_iceI_createStop, name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto createStopAsync(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::SIP::StopPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::StopPrx>, P>(false, this, &StopFactoryPrx::_iceI_createStop, name, context);
    }

    ::std::function<void()>
    createStopAsync(const ::std::string& name,
                    ::std::function<void(::std::shared_ptr<::SIP::StopPrx>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::SIP::StopPrx>>(std::move(response), std::move(ex), std::move(sent), this, &SIP::StopFactoryPrx::_iceI_createStop, name, context);
    }

    /// \cond INTERNAL
    void _iceI_createStop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::StopPrx>>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    double getLoad(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<double>(true, this, &StopFactoryPrx::_iceI_getLoad, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getLoadAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<double>>().get_future())
    {
        return _makePromiseOutgoing<double, P>(false, this, &StopFactoryPrx::_iceI_getLoad, context);
    }

    ::std::function<void()>
    getLoadAsync(::std::function<void(double)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<double>(std::move(response), std::move(ex), std::move(sent), this, &SIP::StopFactoryPrx::_iceI_getLoad, context);
    }

    /// \cond INTERNAL
    void _iceI_getLoad(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<double>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    StopFactoryPrx() = default;
    friend ::std::shared_ptr<StopFactoryPrx> IceInternal::createProxy<StopFactoryPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class MPKPrx : public virtual ::Ice::Proxy<MPKPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<TramStopPrx> getTramStop(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::TramStopPrx>>(true, this, &MPKPrx::_iceI_getTramStop, name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getTramStopAsync(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::SIP::TramStopPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::TramStopPrx>, P>(false, this, &MPKPrx::_iceI_getTramStop, name, context);
    }

    ::std::function<void()>
    getTramStopAsync(const ::std::string& name,
                     ::std::function<void(::std::shared_ptr<::SIP::TramStopPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::SIP::TramStopPrx>>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_getTramStop, name, context);
    }

    /// \cond INTERNAL
    void _iceI_getTramStop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::TramStopPrx>>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void registerDepo(const ::std::shared_ptr<DepoPrx>& depo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MPKPrx::_iceI_registerDepo, depo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerDepoAsync(const ::std::shared_ptr<DepoPrx>& depo, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MPKPrx::_iceI_registerDepo, depo, context);
    }

    ::std::function<void()>
    registerDepoAsync(const ::std::shared_ptr<DepoPrx>& depo,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_registerDepo, depo, context);
    }

    /// \cond INTERNAL
    void _iceI_registerDepo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<DepoPrx>&, const ::Ice::Context&);
    /// \endcond

    void unregisterDepo(const ::std::shared_ptr<DepoPrx>& depo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MPKPrx::_iceI_unregisterDepo, depo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unregisterDepoAsync(const ::std::shared_ptr<DepoPrx>& depo, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MPKPrx::_iceI_unregisterDepo, depo, context);
    }

    ::std::function<void()>
    unregisterDepoAsync(const ::std::shared_ptr<DepoPrx>& depo,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_unregisterDepo, depo, context);
    }

    /// \cond INTERNAL
    void _iceI_unregisterDepo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<DepoPrx>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<DepoPrx> getDepo(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::DepoPrx>>(true, this, &MPKPrx::_iceI_getDepo, name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getDepoAsync(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::SIP::DepoPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::DepoPrx>, P>(false, this, &MPKPrx::_iceI_getDepo, name, context);
    }

    ::std::function<void()>
    getDepoAsync(const ::std::string& name,
                 ::std::function<void(::std::shared_ptr<::SIP::DepoPrx>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::SIP::DepoPrx>>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_getDepo, name, context);
    }

    /// \cond INTERNAL
    void _iceI_getDepo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::DepoPrx>>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    DepoList getDepos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::SIP::DepoList>(true, this, &MPKPrx::_iceI_getDepos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getDeposAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::SIP::DepoList>>().get_future())
    {
        return _makePromiseOutgoing<::SIP::DepoList, P>(false, this, &MPKPrx::_iceI_getDepos, context);
    }

    ::std::function<void()>
    getDeposAsync(::std::function<void(::SIP::DepoList)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::SIP::DepoList>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_getDepos, context);
    }

    /// \cond INTERNAL
    void _iceI_getDepos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::DepoList>>&, const ::Ice::Context&);
    /// \endcond

    LineList getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::SIP::LineList>(true, this, &MPKPrx::_iceI_getLines, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getLinesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::SIP::LineList>>().get_future())
    {
        return _makePromiseOutgoing<::SIP::LineList, P>(false, this, &MPKPrx::_iceI_getLines, context);
    }

    ::std::function<void()>
    getLinesAsync(::std::function<void(::SIP::LineList)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::SIP::LineList>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_getLines, context);
    }

    /// \cond INTERNAL
    void _iceI_getLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::LineList>>&, const ::Ice::Context&);
    /// \endcond

    void registerLineFactory(const ::std::shared_ptr<LineFactoryPrx>& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MPKPrx::_iceI_registerLineFactory, lf, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerLineFactoryAsync(const ::std::shared_ptr<LineFactoryPrx>& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MPKPrx::_iceI_registerLineFactory, lf, context);
    }

    ::std::function<void()>
    registerLineFactoryAsync(const ::std::shared_ptr<LineFactoryPrx>& lf,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_registerLineFactory, lf, context);
    }

    /// \cond INTERNAL
    void _iceI_registerLineFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<LineFactoryPrx>&, const ::Ice::Context&);
    /// \endcond

    void unregisterLineFactory(const ::std::shared_ptr<LineFactoryPrx>& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MPKPrx::_iceI_unregisterLineFactory, lf, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unregisterLineFactoryAsync(const ::std::shared_ptr<LineFactoryPrx>& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MPKPrx::_iceI_unregisterLineFactory, lf, context);
    }

    ::std::function<void()>
    unregisterLineFactoryAsync(const ::std::shared_ptr<LineFactoryPrx>& lf,
                               ::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_unregisterLineFactory, lf, context);
    }

    /// \cond INTERNAL
    void _iceI_unregisterLineFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<LineFactoryPrx>&, const ::Ice::Context&);
    /// \endcond

    void registerStopFactory(const ::std::shared_ptr<StopFactoryPrx>& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MPKPrx::_iceI_registerStopFactory, lf, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerStopFactoryAsync(const ::std::shared_ptr<StopFactoryPrx>& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MPKPrx::_iceI_registerStopFactory, lf, context);
    }

    ::std::function<void()>
    registerStopFactoryAsync(const ::std::shared_ptr<StopFactoryPrx>& lf,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_registerStopFactory, lf, context);
    }

    /// \cond INTERNAL
    void _iceI_registerStopFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<StopFactoryPrx>&, const ::Ice::Context&);
    /// \endcond

    void unregisterStopFactory(const ::std::shared_ptr<StopFactoryPrx>& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MPKPrx::_iceI_unregisterStopFactory, lf, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unregisterStopFactoryAsync(const ::std::shared_ptr<StopFactoryPrx>& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MPKPrx::_iceI_unregisterStopFactory, lf, context);
    }

    ::std::function<void()>
    unregisterStopFactoryAsync(const ::std::shared_ptr<StopFactoryPrx>& lf,
                               ::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::MPKPrx::_iceI_unregisterStopFactory, lf, context);
    }

    /// \cond INTERNAL
    void _iceI_unregisterStopFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<StopFactoryPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MPKPrx() = default;
    friend ::std::shared_ptr<MPKPrx> IceInternal::createProxy<MPKPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class DepoPrx : public virtual ::Ice::Proxy<DepoPrx, ::Ice::ObjectPrx>
{
public:

    void TramOnline(const ::std::shared_ptr<TramPrx>& t, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DepoPrx::_iceI_TramOnline, t, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto TramOnlineAsync(const ::std::shared_ptr<TramPrx>& t, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DepoPrx::_iceI_TramOnline, t, context);
    }

    ::std::function<void()>
    TramOnlineAsync(const ::std::shared_ptr<TramPrx>& t,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::DepoPrx::_iceI_TramOnline, t, context);
    }

    /// \cond INTERNAL
    void _iceI_TramOnline(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const ::Ice::Context&);
    /// \endcond

    void TramOffline(const ::std::shared_ptr<TramPrx>& t, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &DepoPrx::_iceI_TramOffline, t, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto TramOfflineAsync(const ::std::shared_ptr<TramPrx>& t, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &DepoPrx::_iceI_TramOffline, t, context);
    }

    ::std::function<void()>
    TramOfflineAsync(const ::std::shared_ptr<TramPrx>& t,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::DepoPrx::_iceI_TramOffline, t, context);
    }

    /// \cond INTERNAL
    void _iceI_TramOffline(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const ::Ice::Context&);
    /// \endcond

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &DepoPrx::_iceI_getName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &DepoPrx::_iceI_getName, context);
    }

    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &SIP::DepoPrx::_iceI_getName, context);
    }

    /// \cond INTERNAL
    void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    DepoPrx() = default;
    friend ::std::shared_ptr<DepoPrx> IceInternal::createProxy<DepoPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class TramPrx : public virtual ::Ice::Proxy<TramPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<TramStopPrx> getLocation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::TramStopPrx>>(true, this, &TramPrx::_iceI_getLocation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getLocationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::SIP::TramStopPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::TramStopPrx>, P>(false, this, &TramPrx::_iceI_getLocation, context);
    }

    ::std::function<void()>
    getLocationAsync(::std::function<void(::std::shared_ptr<::SIP::TramStopPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::SIP::TramStopPrx>>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramPrx::_iceI_getLocation, context);
    }

    /// \cond INTERNAL
    void _iceI_getLocation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::TramStopPrx>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<LinePrx> getLine(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::LinePrx>>(true, this, &TramPrx::_iceI_getLine, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getLineAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::SIP::LinePrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::SIP::LinePrx>, P>(false, this, &TramPrx::_iceI_getLine, context);
    }

    ::std::function<void()>
    getLineAsync(::std::function<void(::std::shared_ptr<::SIP::LinePrx>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::SIP::LinePrx>>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramPrx::_iceI_getLine, context);
    }

    /// \cond INTERNAL
    void _iceI_getLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::SIP::LinePrx>>>&, const ::Ice::Context&);
    /// \endcond

    void setLine(const ::std::shared_ptr<LinePrx>& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TramPrx::_iceI_setLine, line, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setLineAsync(const ::std::shared_ptr<LinePrx>& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TramPrx::_iceI_setLine, line, context);
    }

    ::std::function<void()>
    setLineAsync(const ::std::shared_ptr<LinePrx>& line,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramPrx::_iceI_setLine, line, context);
    }

    /// \cond INTERNAL
    void _iceI_setLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<LinePrx>&, const ::Ice::Context&);
    /// \endcond

    StopList getNextStops(int howMany, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::SIP::StopList>(true, this, &TramPrx::_iceI_getNextStops, howMany, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNextStopsAsync(int howMany, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::SIP::StopList>>().get_future())
    {
        return _makePromiseOutgoing<::SIP::StopList, P>(false, this, &TramPrx::_iceI_getNextStops, howMany, context);
    }

    ::std::function<void()>
    getNextStopsAsync(int howMany,
                      ::std::function<void(::SIP::StopList)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::SIP::StopList>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramPrx::_iceI_getNextStops, howMany, context);
    }

    /// \cond INTERNAL
    void _iceI_getNextStops(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::SIP::StopList>>&, int, const ::Ice::Context&);
    /// \endcond

    void RegisterPassenger(const ::std::shared_ptr<PassengerPrx>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TramPrx::_iceI_RegisterPassenger, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RegisterPassengerAsync(const ::std::shared_ptr<PassengerPrx>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TramPrx::_iceI_RegisterPassenger, p, context);
    }

    ::std::function<void()>
    RegisterPassengerAsync(const ::std::shared_ptr<PassengerPrx>& p,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramPrx::_iceI_RegisterPassenger, p, context);
    }

    /// \cond INTERNAL
    void _iceI_RegisterPassenger(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<PassengerPrx>&, const ::Ice::Context&);
    /// \endcond

    void UnregisterPassenger(const ::std::shared_ptr<PassengerPrx>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TramPrx::_iceI_UnregisterPassenger, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UnregisterPassengerAsync(const ::std::shared_ptr<PassengerPrx>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TramPrx::_iceI_UnregisterPassenger, p, context);
    }

    ::std::function<void()>
    UnregisterPassengerAsync(const ::std::shared_ptr<PassengerPrx>& p,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramPrx::_iceI_UnregisterPassenger, p, context);
    }

    /// \cond INTERNAL
    void _iceI_UnregisterPassenger(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<PassengerPrx>&, const ::Ice::Context&);
    /// \endcond

    ::std::string getStockNumber(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &TramPrx::_iceI_getStockNumber, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStockNumberAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &TramPrx::_iceI_getStockNumber, context);
    }

    ::std::function<void()>
    getStockNumberAsync(::std::function<void(::std::string)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &SIP::TramPrx::_iceI_getStockNumber, context);
    }

    /// \cond INTERNAL
    void _iceI_getStockNumber(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TramPrx() = default;
    friend ::std::shared_ptr<TramPrx> IceInternal::createProxy<TramPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class PassengerPrx : public virtual ::Ice::Proxy<PassengerPrx, ::Ice::ObjectPrx>
{
public:

    void updateTramInfo(const ::std::shared_ptr<TramPrx>& tram, const StopList& stops, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &PassengerPrx::_iceI_updateTramInfo, tram, stops, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto updateTramInfoAsync(const ::std::shared_ptr<TramPrx>& tram, const StopList& stops, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &PassengerPrx::_iceI_updateTramInfo, tram, stops, context);
    }

    ::std::function<void()>
    updateTramInfoAsync(const ::std::shared_ptr<TramPrx>& tram, const StopList& stops,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::PassengerPrx::_iceI_updateTramInfo, tram, stops, context);
    }

    /// \cond INTERNAL
    void _iceI_updateTramInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const StopList&, const ::Ice::Context&);
    /// \endcond

    void updateStopInfo(const ::std::shared_ptr<StopPrx>& stop, const TramList& trams, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &PassengerPrx::_iceI_updateStopInfo, stop, trams, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto updateStopInfoAsync(const ::std::shared_ptr<StopPrx>& stop, const TramList& trams, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &PassengerPrx::_iceI_updateStopInfo, stop, trams, context);
    }

    ::std::function<void()>
    updateStopInfoAsync(const ::std::shared_ptr<StopPrx>& stop, const TramList& trams,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &SIP::PassengerPrx::_iceI_updateStopInfo, stop, trams, context);
    }

    /// \cond INTERNAL
    void _iceI_updateStopInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<StopPrx>&, const TramList&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    PassengerPrx() = default;
    friend ::std::shared_ptr<PassengerPrx> IceInternal::createProxy<PassengerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::SIP::Time>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::SIP::Time, S>
{
    static void read(S* istr, ::SIP::Time& v)
    {
        istr->readAll(v.hour, v.minute);
    }
};

template<>
struct StreamableTraits<::SIP::StopInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::SIP::StopInfo, S>
{
    static void read(S* istr, ::SIP::StopInfo& v)
    {
        istr->readAll(v.time, v.stop);
    }
};

template<>
struct StreamableTraits<::SIP::TramInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::SIP::TramInfo, S>
{
    static void read(S* istr, ::SIP::TramInfo& v)
    {
        istr->readAll(v.time, v.tram);
    }
};

template<>
struct StreamableTraits<::SIP::DepoInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::SIP::DepoInfo, S>
{
    static void read(S* istr, ::SIP::DepoInfo& v)
    {
        istr->readAll(v.name, v.stop);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace SIP
{

using TramPtr = ::std::shared_ptr<Tram>;
using TramPrxPtr = ::std::shared_ptr<TramPrx>;

using TramStopPtr = ::std::shared_ptr<TramStop>;
using TramStopPrxPtr = ::std::shared_ptr<TramStopPrx>;

using DepoPtr = ::std::shared_ptr<Depo>;
using DepoPrxPtr = ::std::shared_ptr<DepoPrx>;

using PassengerPtr = ::std::shared_ptr<Passenger>;
using PassengerPrxPtr = ::std::shared_ptr<PassengerPrx>;

using StopPtr = ::std::shared_ptr<Stop>;
using StopPrxPtr = ::std::shared_ptr<StopPrx>;

using LinePtr = ::std::shared_ptr<Line>;
using LinePrxPtr = ::std::shared_ptr<LinePrx>;

using LineFactoryPtr = ::std::shared_ptr<LineFactory>;
using LineFactoryPrxPtr = ::std::shared_ptr<LineFactoryPrx>;

using StopFactoryPtr = ::std::shared_ptr<StopFactory>;
using StopFactoryPrxPtr = ::std::shared_ptr<StopFactoryPrx>;

using MPKPtr = ::std::shared_ptr<MPK>;
using MPKPrxPtr = ::std::shared_ptr<MPKPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace SIP
{

class Tram;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Tram>&);
::IceProxy::Ice::Object* upCast(Tram*);
/// \endcond

class TramStop;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< TramStop>&);
::IceProxy::Ice::Object* upCast(TramStop*);
/// \endcond

class Depo;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Depo>&);
::IceProxy::Ice::Object* upCast(Depo*);
/// \endcond

class Passenger;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Passenger>&);
::IceProxy::Ice::Object* upCast(Passenger*);
/// \endcond

class Stop;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Stop>&);
::IceProxy::Ice::Object* upCast(Stop*);
/// \endcond

class Line;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Line>&);
::IceProxy::Ice::Object* upCast(Line*);
/// \endcond

class LineFactory;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< LineFactory>&);
::IceProxy::Ice::Object* upCast(LineFactory*);
/// \endcond

class StopFactory;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< StopFactory>&);
::IceProxy::Ice::Object* upCast(StopFactory*);
/// \endcond

class MPK;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MPK>&);
::IceProxy::Ice::Object* upCast(MPK*);
/// \endcond

}

}

namespace SIP
{

class Tram;
/// \cond INTERNAL
::Ice::Object* upCast(Tram*);
/// \endcond
typedef ::IceInternal::Handle< Tram> TramPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::Tram> TramPrx;
typedef TramPrx TramPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(TramPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class TramStop;
/// \cond INTERNAL
::Ice::Object* upCast(TramStop*);
/// \endcond
typedef ::IceInternal::Handle< TramStop> TramStopPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::TramStop> TramStopPrx;
typedef TramStopPrx TramStopPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(TramStopPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Depo;
/// \cond INTERNAL
::Ice::Object* upCast(Depo*);
/// \endcond
typedef ::IceInternal::Handle< Depo> DepoPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::Depo> DepoPrx;
typedef DepoPrx DepoPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(DepoPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Passenger;
/// \cond INTERNAL
::Ice::Object* upCast(Passenger*);
/// \endcond
typedef ::IceInternal::Handle< Passenger> PassengerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::Passenger> PassengerPrx;
typedef PassengerPrx PassengerPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PassengerPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Stop;
/// \cond INTERNAL
::Ice::Object* upCast(Stop*);
/// \endcond
typedef ::IceInternal::Handle< Stop> StopPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::Stop> StopPrx;
typedef StopPrx StopPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(StopPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Line;
/// \cond INTERNAL
::Ice::Object* upCast(Line*);
/// \endcond
typedef ::IceInternal::Handle< Line> LinePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::Line> LinePrx;
typedef LinePrx LinePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LinePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class LineFactory;
/// \cond INTERNAL
::Ice::Object* upCast(LineFactory*);
/// \endcond
typedef ::IceInternal::Handle< LineFactory> LineFactoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::LineFactory> LineFactoryPrx;
typedef LineFactoryPrx LineFactoryPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LineFactoryPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class StopFactory;
/// \cond INTERNAL
::Ice::Object* upCast(StopFactory*);
/// \endcond
typedef ::IceInternal::Handle< StopFactory> StopFactoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::StopFactory> StopFactoryPrx;
typedef StopFactoryPrx StopFactoryPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(StopFactoryPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class MPK;
/// \cond INTERNAL
::Ice::Object* upCast(MPK*);
/// \endcond
typedef ::IceInternal::Handle< MPK> MPKPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::SIP::MPK> MPKPrx;
typedef MPKPrx MPKPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MPKPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace SIP
{

struct Time
{
    ::Ice::Int hour;
    ::Ice::Int minute;

    bool operator==(const Time& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(hour != rhs_.hour)
        {
            return false;
        }
        if(minute != rhs_.minute)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Time& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(hour < rhs_.hour)
        {
            return true;
        }
        else if(rhs_.hour < hour)
        {
            return false;
        }
        if(minute < rhs_.minute)
        {
            return true;
        }
        else if(rhs_.minute < minute)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Time& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Time& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Time& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Time& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct StopInfo
{
    ::SIP::Time time;
    ::SIP::TramStopPrx stop;
};

typedef ::std::vector<StopInfo> StopList;

struct TramInfo
{
    ::SIP::Time time;
    ::SIP::TramPrx tram;
};

typedef ::std::vector<TramInfo> TramList;

struct DepoInfo
{
    ::std::string name;
    ::SIP::DepoPrx stop;
};

typedef ::std::vector<DepoInfo> DepoList;

typedef ::std::vector<LinePrx> LineList;

}

namespace SIP
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::TramStop::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_getName.
 */
class Callback_TramStop_getName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TramStop_getName_Base> Callback_TramStop_getNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::TramStop::begin_getNextTrams.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_getNextTrams.
 */
class Callback_TramStop_getNextTrams_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TramStop_getNextTrams_Base> Callback_TramStop_getNextTramsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::TramStop::begin_RegisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_RegisterPassenger.
 */
class Callback_TramStop_RegisterPassenger_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TramStop_RegisterPassenger_Base> Callback_TramStop_RegisterPassengerPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_UnregisterPassenger.
 */
class Callback_TramStop_UnregisterPassenger_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TramStop_UnregisterPassenger_Base> Callback_TramStop_UnregisterPassengerPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_UpdateTramInfo.
 */
class Callback_TramStop_UpdateTramInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TramStop_UpdateTramInfo_Base> Callback_TramStop_UpdateTramInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Line::begin_getTrams.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getTrams.
 */
class Callback_Line_getTrams_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_getTrams_Base> Callback_Line_getTramsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Line::begin_getStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getStops.
 */
class Callback_Line_getStops_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_getStops_Base> Callback_Line_getStopsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Line::begin_registerTram.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_registerTram.
 */
class Callback_Line_registerTram_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_registerTram_Base> Callback_Line_registerTramPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Line::begin_unregisterTram.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_unregisterTram.
 */
class Callback_Line_unregisterTram_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_unregisterTram_Base> Callback_Line_unregisterTramPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Line::begin_setStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_setStops.
 */
class Callback_Line_setStops_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_setStops_Base> Callback_Line_setStopsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Line::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getName.
 */
class Callback_Line_getName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_getName_Base> Callback_Line_getNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::LineFactory::begin_createLine.
 * Create a wrapper instance by calling ::SIP::newCallback_LineFactory_createLine.
 */
class Callback_LineFactory_createLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LineFactory_createLine_Base> Callback_LineFactory_createLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::LineFactory::begin_getLoad.
 * Create a wrapper instance by calling ::SIP::newCallback_LineFactory_getLoad.
 */
class Callback_LineFactory_getLoad_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LineFactory_getLoad_Base> Callback_LineFactory_getLoadPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::StopFactory::begin_createStop.
 * Create a wrapper instance by calling ::SIP::newCallback_StopFactory_createStop.
 */
class Callback_StopFactory_createStop_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StopFactory_createStop_Base> Callback_StopFactory_createStopPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::StopFactory::begin_getLoad.
 * Create a wrapper instance by calling ::SIP::newCallback_StopFactory_getLoad.
 */
class Callback_StopFactory_getLoad_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StopFactory_getLoad_Base> Callback_StopFactory_getLoadPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_getTramStop.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getTramStop.
 */
class Callback_MPK_getTramStop_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_getTramStop_Base> Callback_MPK_getTramStopPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_registerDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerDepo.
 */
class Callback_MPK_registerDepo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_registerDepo_Base> Callback_MPK_registerDepoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_unregisterDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterDepo.
 */
class Callback_MPK_unregisterDepo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_unregisterDepo_Base> Callback_MPK_unregisterDepoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_getDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getDepo.
 */
class Callback_MPK_getDepo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_getDepo_Base> Callback_MPK_getDepoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_getDepos.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getDepos.
 */
class Callback_MPK_getDepos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_getDepos_Base> Callback_MPK_getDeposPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_getLines.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getLines.
 */
class Callback_MPK_getLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_getLines_Base> Callback_MPK_getLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_registerLineFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerLineFactory.
 */
class Callback_MPK_registerLineFactory_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_registerLineFactory_Base> Callback_MPK_registerLineFactoryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_unregisterLineFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterLineFactory.
 */
class Callback_MPK_unregisterLineFactory_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_unregisterLineFactory_Base> Callback_MPK_unregisterLineFactoryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_registerStopFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerStopFactory.
 */
class Callback_MPK_registerStopFactory_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_registerStopFactory_Base> Callback_MPK_registerStopFactoryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::MPK::begin_unregisterStopFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterStopFactory.
 */
class Callback_MPK_unregisterStopFactory_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MPK_unregisterStopFactory_Base> Callback_MPK_unregisterStopFactoryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Depo::begin_TramOnline.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_TramOnline.
 */
class Callback_Depo_TramOnline_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Depo_TramOnline_Base> Callback_Depo_TramOnlinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Depo::begin_TramOffline.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_TramOffline.
 */
class Callback_Depo_TramOffline_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Depo_TramOffline_Base> Callback_Depo_TramOfflinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Depo::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_getName.
 */
class Callback_Depo_getName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Depo_getName_Base> Callback_Depo_getNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Tram::begin_getLocation.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getLocation.
 */
class Callback_Tram_getLocation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_getLocation_Base> Callback_Tram_getLocationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Tram::begin_getLine.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getLine.
 */
class Callback_Tram_getLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_getLine_Base> Callback_Tram_getLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Tram::begin_setLine.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_setLine.
 */
class Callback_Tram_setLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_setLine_Base> Callback_Tram_setLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Tram::begin_getNextStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getNextStops.
 */
class Callback_Tram_getNextStops_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_getNextStops_Base> Callback_Tram_getNextStopsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Tram::begin_RegisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_RegisterPassenger.
 */
class Callback_Tram_RegisterPassenger_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_RegisterPassenger_Base> Callback_Tram_RegisterPassengerPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Tram::begin_UnregisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_UnregisterPassenger.
 */
class Callback_Tram_UnregisterPassenger_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_UnregisterPassenger_Base> Callback_Tram_UnregisterPassengerPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Tram::begin_getStockNumber.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getStockNumber.
 */
class Callback_Tram_getStockNumber_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_getStockNumber_Base> Callback_Tram_getStockNumberPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Passenger::begin_updateTramInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_Passenger_updateTramInfo.
 */
class Callback_Passenger_updateTramInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Passenger_updateTramInfo_Base> Callback_Passenger_updateTramInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::SIP::Passenger::begin_updateStopInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_Passenger_updateStopInfo.
 */
class Callback_Passenger_updateStopInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Passenger_updateStopInfo_Base> Callback_Passenger_updateStopInfoPtr;

}

namespace IceProxy
{

namespace SIP
{

class TramStop : public virtual ::Ice::Proxy<TramStop, ::IceProxy::Ice::Object>
{
public:

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getName(_iceI_begin_getName(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getName(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::SIP::Callback_TramStop_getNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::SIP::Callback_TramStop_getNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, cb, cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getName(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::SIP::TramList getNextTrams(::Ice::Int howMany, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getNextTrams(_iceI_begin_getNextTrams(howMany, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getNextTrams(::Ice::Int howMany, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getNextTrams(howMany, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNextTrams(::Ice::Int howMany, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNextTrams(howMany, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNextTrams(::Ice::Int howMany, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNextTrams(howMany, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNextTrams(::Ice::Int howMany, const ::SIP::Callback_TramStop_getNextTramsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNextTrams(howMany, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNextTrams(::Ice::Int howMany, const ::Ice::Context& context, const ::SIP::Callback_TramStop_getNextTramsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNextTrams(howMany, context, cb, cookie);
    }

    ::SIP::TramList end_getNextTrams(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getNextTrams(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RegisterPassenger(_iceI_begin_RegisterPassenger(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RegisterPassenger(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RegisterPassenger(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RegisterPassenger(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::SIP::Callback_TramStop_RegisterPassengerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RegisterPassenger(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context, const ::SIP::Callback_TramStop_RegisterPassengerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RegisterPassenger(p, context, cb, cookie);
    }

    void end_RegisterPassenger(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RegisterPassenger(const ::SIP::PassengerPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UnregisterPassenger(_iceI_begin_UnregisterPassenger(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UnregisterPassenger(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UnregisterPassenger(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UnregisterPassenger(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::SIP::Callback_TramStop_UnregisterPassengerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UnregisterPassenger(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context, const ::SIP::Callback_TramStop_UnregisterPassengerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UnregisterPassenger(p, context, cb, cookie);
    }

    void end_UnregisterPassenger(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UnregisterPassenger(const ::SIP::PassengerPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UpdateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::Time& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UpdateTramInfo(_iceI_begin_UpdateTramInfo(tram, time, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::Time& time, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateTramInfo(tram, time, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::Time& time, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTramInfo(tram, time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::Time& time, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTramInfo(tram, time, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::Time& time, const ::SIP::Callback_TramStop_UpdateTramInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTramInfo(tram, time, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::Time& time, const ::Ice::Context& context, const ::SIP::Callback_TramStop_UpdateTramInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTramInfo(tram, time, context, cb, cookie);
    }

    void end_UpdateTramInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateTramInfo(const ::SIP::TramPrx&, const ::SIP::Time&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Line : public virtual ::Ice::Proxy<Line, ::IceProxy::Ice::Object>
{
public:

    ::SIP::TramList getTrams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getTrams(_iceI_begin_getTrams(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getTrams(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTrams(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTrams(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::SIP::Callback_Line_getTramsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTrams(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::Ice::Context& context, const ::SIP::Callback_Line_getTramsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTrams(context, cb, cookie);
    }

    ::SIP::TramList end_getTrams(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getTrams(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::SIP::StopList getStops(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStops(_iceI_begin_getStops(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStops(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStops(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStops(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::SIP::Callback_Line_getStopsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStops(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::Ice::Context& context, const ::SIP::Callback_Line_getStopsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStops(context, cb, cookie);
    }

    ::SIP::StopList end_getStops(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStops(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void registerTram(const ::SIP::TramPrx& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_registerTram(_iceI_begin_registerTram(tram, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerTram(const ::SIP::TramPrx& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerTram(tram, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerTram(const ::SIP::TramPrx& tram, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerTram(tram, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerTram(const ::SIP::TramPrx& tram, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerTram(tram, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerTram(const ::SIP::TramPrx& tram, const ::SIP::Callback_Line_registerTramPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerTram(tram, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerTram(const ::SIP::TramPrx& tram, const ::Ice::Context& context, const ::SIP::Callback_Line_registerTramPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerTram(tram, context, cb, cookie);
    }

    void end_registerTram(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerTram(const ::SIP::TramPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unregisterTram(const ::SIP::TramPrx& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unregisterTram(_iceI_begin_unregisterTram(tram, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unregisterTram(const ::SIP::TramPrx& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unregisterTram(tram, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterTram(const ::SIP::TramPrx& tram, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterTram(tram, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterTram(const ::SIP::TramPrx& tram, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterTram(tram, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterTram(const ::SIP::TramPrx& tram, const ::SIP::Callback_Line_unregisterTramPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterTram(tram, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterTram(const ::SIP::TramPrx& tram, const ::Ice::Context& context, const ::SIP::Callback_Line_unregisterTramPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterTram(tram, context, cb, cookie);
    }

    void end_unregisterTram(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unregisterTram(const ::SIP::TramPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setStops(const ::SIP::StopList& sl, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setStops(_iceI_begin_setStops(sl, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setStops(const ::SIP::StopList& sl, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setStops(sl, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStops(const ::SIP::StopList& sl, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setStops(sl, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setStops(const ::SIP::StopList& sl, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setStops(sl, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setStops(const ::SIP::StopList& sl, const ::SIP::Callback_Line_setStopsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setStops(sl, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setStops(const ::SIP::StopList& sl, const ::Ice::Context& context, const ::SIP::Callback_Line_setStopsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setStops(sl, context, cb, cookie);
    }

    void end_setStops(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setStops(const ::SIP::StopList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getName(_iceI_begin_getName(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getName(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::SIP::Callback_Line_getNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::SIP::Callback_Line_getNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, cb, cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getName(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class LineFactory : public virtual ::Ice::Proxy<LineFactory, ::IceProxy::Ice::Object>
{
public:

    ::SIP::LinePrx createLine(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_createLine(_iceI_begin_createLine(name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_createLine(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_createLine(name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createLine(const ::std::string& name, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createLine(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createLine(const ::std::string& name, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createLine(name, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createLine(const ::std::string& name, const ::SIP::Callback_LineFactory_createLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createLine(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createLine(const ::std::string& name, const ::Ice::Context& context, const ::SIP::Callback_LineFactory_createLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createLine(name, context, cb, cookie);
    }

    ::SIP::LinePrx end_createLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_createLine(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Double getLoad(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getLoad(_iceI_begin_getLoad(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getLoad(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLoad(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLoad(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::SIP::Callback_LineFactory_getLoadPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLoad(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::Ice::Context& context, const ::SIP::Callback_LineFactory_getLoadPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLoad(context, cb, cookie);
    }

    ::Ice::Double end_getLoad(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getLoad(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class StopFactory : public virtual ::Ice::Proxy<StopFactory, ::IceProxy::Ice::Object>
{
public:

    ::SIP::StopPrx createStop(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_createStop(_iceI_begin_createStop(name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_createStop(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_createStop(name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createStop(const ::std::string& name, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createStop(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createStop(const ::std::string& name, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createStop(name, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createStop(const ::std::string& name, const ::SIP::Callback_StopFactory_createStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createStop(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createStop(const ::std::string& name, const ::Ice::Context& context, const ::SIP::Callback_StopFactory_createStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createStop(name, context, cb, cookie);
    }

    ::SIP::StopPrx end_createStop(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_createStop(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Double getLoad(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getLoad(_iceI_begin_getLoad(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getLoad(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLoad(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLoad(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::SIP::Callback_StopFactory_getLoadPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLoad(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLoad(const ::Ice::Context& context, const ::SIP::Callback_StopFactory_getLoadPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLoad(context, cb, cookie);
    }

    ::Ice::Double end_getLoad(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getLoad(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class MPK : public virtual ::Ice::Proxy<MPK, ::IceProxy::Ice::Object>
{
public:

    ::SIP::TramStopPrx getTramStop(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getTramStop(_iceI_begin_getTramStop(name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getTramStop(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getTramStop(name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTramStop(const ::std::string& name, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTramStop(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTramStop(const ::std::string& name, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTramStop(name, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTramStop(const ::std::string& name, const ::SIP::Callback_MPK_getTramStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTramStop(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTramStop(const ::std::string& name, const ::Ice::Context& context, const ::SIP::Callback_MPK_getTramStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTramStop(name, context, cb, cookie);
    }

    ::SIP::TramStopPrx end_getTramStop(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getTramStop(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void registerDepo(const ::SIP::DepoPrx& depo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_registerDepo(_iceI_begin_registerDepo(depo, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerDepo(const ::SIP::DepoPrx& depo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerDepo(depo, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerDepo(const ::SIP::DepoPrx& depo, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerDepo(depo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerDepo(const ::SIP::DepoPrx& depo, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerDepo(depo, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerDepo(const ::SIP::DepoPrx& depo, const ::SIP::Callback_MPK_registerDepoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerDepo(depo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerDepo(const ::SIP::DepoPrx& depo, const ::Ice::Context& context, const ::SIP::Callback_MPK_registerDepoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerDepo(depo, context, cb, cookie);
    }

    void end_registerDepo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerDepo(const ::SIP::DepoPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unregisterDepo(const ::SIP::DepoPrx& depo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unregisterDepo(_iceI_begin_unregisterDepo(depo, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unregisterDepo(const ::SIP::DepoPrx& depo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unregisterDepo(depo, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterDepo(const ::SIP::DepoPrx& depo, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterDepo(depo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterDepo(const ::SIP::DepoPrx& depo, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterDepo(depo, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterDepo(const ::SIP::DepoPrx& depo, const ::SIP::Callback_MPK_unregisterDepoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterDepo(depo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterDepo(const ::SIP::DepoPrx& depo, const ::Ice::Context& context, const ::SIP::Callback_MPK_unregisterDepoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterDepo(depo, context, cb, cookie);
    }

    void end_unregisterDepo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unregisterDepo(const ::SIP::DepoPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::SIP::DepoPrx getDepo(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getDepo(_iceI_begin_getDepo(name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getDepo(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getDepo(name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDepo(const ::std::string& name, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDepo(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepo(const ::std::string& name, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDepo(name, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepo(const ::std::string& name, const ::SIP::Callback_MPK_getDepoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDepo(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepo(const ::std::string& name, const ::Ice::Context& context, const ::SIP::Callback_MPK_getDepoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDepo(name, context, cb, cookie);
    }

    ::SIP::DepoPrx end_getDepo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getDepo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::SIP::DepoList getDepos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getDepos(_iceI_begin_getDepos(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getDepos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getDepos(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDepos(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDepos(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepos(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDepos(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepos(const ::SIP::Callback_MPK_getDeposPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDepos(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepos(const ::Ice::Context& context, const ::SIP::Callback_MPK_getDeposPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDepos(context, cb, cookie);
    }

    ::SIP::DepoList end_getDepos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getDepos(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::SIP::LineList getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getLines(_iceI_begin_getLines(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getLines(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::SIP::Callback_MPK_getLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context, const ::SIP::Callback_MPK_getLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(context, cb, cookie);
    }

    ::SIP::LineList end_getLines(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getLines(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void registerLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_registerLineFactory(_iceI_begin_registerLineFactory(lf, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerLineFactory(lf, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerLineFactory(lf, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerLineFactory(lf, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerLineFactory(const ::SIP::LineFactoryPrx& lf, const ::SIP::Callback_MPK_registerLineFactoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerLineFactory(lf, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::Context& context, const ::SIP::Callback_MPK_registerLineFactoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerLineFactory(lf, context, cb, cookie);
    }

    void end_registerLineFactory(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerLineFactory(const ::SIP::LineFactoryPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unregisterLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unregisterLineFactory(_iceI_begin_unregisterLineFactory(lf, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unregisterLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unregisterLineFactory(lf, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterLineFactory(lf, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterLineFactory(lf, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterLineFactory(const ::SIP::LineFactoryPrx& lf, const ::SIP::Callback_MPK_unregisterLineFactoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterLineFactory(lf, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterLineFactory(const ::SIP::LineFactoryPrx& lf, const ::Ice::Context& context, const ::SIP::Callback_MPK_unregisterLineFactoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterLineFactory(lf, context, cb, cookie);
    }

    void end_unregisterLineFactory(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unregisterLineFactory(const ::SIP::LineFactoryPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void registerStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_registerStopFactory(_iceI_begin_registerStopFactory(lf, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerStopFactory(lf, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerStopFactory(lf, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerStopFactory(lf, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerStopFactory(const ::SIP::StopFactoryPrx& lf, const ::SIP::Callback_MPK_registerStopFactoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerStopFactory(lf, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::Context& context, const ::SIP::Callback_MPK_registerStopFactoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerStopFactory(lf, context, cb, cookie);
    }

    void end_registerStopFactory(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerStopFactory(const ::SIP::StopFactoryPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unregisterStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unregisterStopFactory(_iceI_begin_unregisterStopFactory(lf, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unregisterStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unregisterStopFactory(lf, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterStopFactory(lf, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterStopFactory(lf, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterStopFactory(const ::SIP::StopFactoryPrx& lf, const ::SIP::Callback_MPK_unregisterStopFactoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterStopFactory(lf, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterStopFactory(const ::SIP::StopFactoryPrx& lf, const ::Ice::Context& context, const ::SIP::Callback_MPK_unregisterStopFactoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterStopFactory(lf, context, cb, cookie);
    }

    void end_unregisterStopFactory(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unregisterStopFactory(const ::SIP::StopFactoryPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Depo : public virtual ::Ice::Proxy<Depo, ::IceProxy::Ice::Object>
{
public:

    void TramOnline(const ::SIP::TramPrx& t, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_TramOnline(_iceI_begin_TramOnline(t, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_TramOnline(const ::SIP::TramPrx& t, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_TramOnline(t, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TramOnline(const ::SIP::TramPrx& t, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TramOnline(t, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TramOnline(const ::SIP::TramPrx& t, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TramOnline(t, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TramOnline(const ::SIP::TramPrx& t, const ::SIP::Callback_Depo_TramOnlinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TramOnline(t, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TramOnline(const ::SIP::TramPrx& t, const ::Ice::Context& context, const ::SIP::Callback_Depo_TramOnlinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TramOnline(t, context, cb, cookie);
    }

    void end_TramOnline(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_TramOnline(const ::SIP::TramPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void TramOffline(const ::SIP::TramPrx& t, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_TramOffline(_iceI_begin_TramOffline(t, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_TramOffline(const ::SIP::TramPrx& t, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_TramOffline(t, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TramOffline(const ::SIP::TramPrx& t, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TramOffline(t, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TramOffline(const ::SIP::TramPrx& t, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TramOffline(t, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TramOffline(const ::SIP::TramPrx& t, const ::SIP::Callback_Depo_TramOfflinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TramOffline(t, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TramOffline(const ::SIP::TramPrx& t, const ::Ice::Context& context, const ::SIP::Callback_Depo_TramOfflinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TramOffline(t, context, cb, cookie);
    }

    void end_TramOffline(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_TramOffline(const ::SIP::TramPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getName(_iceI_begin_getName(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getName(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::SIP::Callback_Depo_getNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::SIP::Callback_Depo_getNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, cb, cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getName(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Tram : public virtual ::Ice::Proxy<Tram, ::IceProxy::Ice::Object>
{
public:

    ::SIP::TramStopPrx getLocation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getLocation(_iceI_begin_getLocation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getLocation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLocation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLocation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::SIP::Callback_Tram_getLocationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLocation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocation(const ::Ice::Context& context, const ::SIP::Callback_Tram_getLocationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLocation(context, cb, cookie);
    }

    ::SIP::TramStopPrx end_getLocation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getLocation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::SIP::LinePrx getLine(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getLine(_iceI_begin_getLine(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getLine(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getLine(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLine(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLine(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLine(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLine(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLine(const ::SIP::Callback_Tram_getLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLine(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLine(const ::Ice::Context& context, const ::SIP::Callback_Tram_getLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLine(context, cb, cookie);
    }

    ::SIP::LinePrx end_getLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getLine(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setLine(const ::SIP::LinePrx& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setLine(_iceI_begin_setLine(line, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setLine(const ::SIP::LinePrx& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setLine(line, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLine(const ::SIP::LinePrx& line, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLine(line, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLine(const ::SIP::LinePrx& line, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLine(line, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLine(const ::SIP::LinePrx& line, const ::SIP::Callback_Tram_setLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLine(line, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLine(const ::SIP::LinePrx& line, const ::Ice::Context& context, const ::SIP::Callback_Tram_setLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLine(line, context, cb, cookie);
    }

    void end_setLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setLine(const ::SIP::LinePrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::SIP::StopList getNextStops(::Ice::Int howMany, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getNextStops(_iceI_begin_getNextStops(howMany, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getNextStops(::Ice::Int howMany, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getNextStops(howMany, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNextStops(::Ice::Int howMany, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNextStops(howMany, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNextStops(::Ice::Int howMany, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNextStops(howMany, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNextStops(::Ice::Int howMany, const ::SIP::Callback_Tram_getNextStopsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNextStops(howMany, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNextStops(::Ice::Int howMany, const ::Ice::Context& context, const ::SIP::Callback_Tram_getNextStopsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNextStops(howMany, context, cb, cookie);
    }

    ::SIP::StopList end_getNextStops(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getNextStops(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_RegisterPassenger(_iceI_begin_RegisterPassenger(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RegisterPassenger(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RegisterPassenger(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RegisterPassenger(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::SIP::Callback_Tram_RegisterPassengerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RegisterPassenger(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RegisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context, const ::SIP::Callback_Tram_RegisterPassengerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RegisterPassenger(p, context, cb, cookie);
    }

    void end_RegisterPassenger(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RegisterPassenger(const ::SIP::PassengerPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UnregisterPassenger(_iceI_begin_UnregisterPassenger(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UnregisterPassenger(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UnregisterPassenger(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UnregisterPassenger(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::SIP::Callback_Tram_UnregisterPassengerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UnregisterPassenger(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UnregisterPassenger(const ::SIP::PassengerPrx& p, const ::Ice::Context& context, const ::SIP::Callback_Tram_UnregisterPassengerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UnregisterPassenger(p, context, cb, cookie);
    }

    void end_UnregisterPassenger(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UnregisterPassenger(const ::SIP::PassengerPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string getStockNumber(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStockNumber(_iceI_begin_getStockNumber(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStockNumber(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStockNumber(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStockNumber(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStockNumber(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStockNumber(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStockNumber(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStockNumber(const ::SIP::Callback_Tram_getStockNumberPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStockNumber(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStockNumber(const ::Ice::Context& context, const ::SIP::Callback_Tram_getStockNumberPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStockNumber(context, cb, cookie);
    }

    ::std::string end_getStockNumber(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStockNumber(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Passenger : public virtual ::Ice::Proxy<Passenger, ::IceProxy::Ice::Object>
{
public:

    void updateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::StopList& stops, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_updateTramInfo(_iceI_begin_updateTramInfo(tram, stops, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_updateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::StopList& stops, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_updateTramInfo(tram, stops, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::StopList& stops, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateTramInfo(tram, stops, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::StopList& stops, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateTramInfo(tram, stops, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::StopList& stops, const ::SIP::Callback_Passenger_updateTramInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateTramInfo(tram, stops, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateTramInfo(const ::SIP::TramPrx& tram, const ::SIP::StopList& stops, const ::Ice::Context& context, const ::SIP::Callback_Passenger_updateTramInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateTramInfo(tram, stops, context, cb, cookie);
    }

    void end_updateTramInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_updateTramInfo(const ::SIP::TramPrx&, const ::SIP::StopList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void updateStopInfo(const ::SIP::StopPrx& stop, const ::SIP::TramList& trams, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_updateStopInfo(_iceI_begin_updateStopInfo(stop, trams, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_updateStopInfo(const ::SIP::StopPrx& stop, const ::SIP::TramList& trams, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_updateStopInfo(stop, trams, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateStopInfo(const ::SIP::StopPrx& stop, const ::SIP::TramList& trams, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateStopInfo(stop, trams, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateStopInfo(const ::SIP::StopPrx& stop, const ::SIP::TramList& trams, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateStopInfo(stop, trams, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateStopInfo(const ::SIP::StopPrx& stop, const ::SIP::TramList& trams, const ::SIP::Callback_Passenger_updateStopInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateStopInfo(stop, trams, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateStopInfo(const ::SIP::StopPrx& stop, const ::SIP::TramList& trams, const ::Ice::Context& context, const ::SIP::Callback_Passenger_updateStopInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateStopInfo(stop, trams, context, cb, cookie);
    }

    void end_updateStopInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_updateStopInfo(const ::SIP::StopPrx&, const ::SIP::TramList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace SIP
{

class TramStop : public virtual ::Ice::Object
{
public:

    typedef TramStopPrx ProxyType;
    typedef TramStopPtr PointerType;

    virtual ~TramStop();

#ifdef ICE_CPP11_COMPILER
    TramStop() = default;
    TramStop(const TramStop&) = default;
    TramStop& operator=(const TramStop&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::string getName(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TramList getNextTrams(::Ice::Int howMany, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getNextTrams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RegisterPassenger(const PassengerPrx& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RegisterPassenger(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UnregisterPassenger(const PassengerPrx& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UnregisterPassenger(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UpdateTramInfo(const TramPrx& tram, const Time& time, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateTramInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const TramStop& lhs, const TramStop& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const TramStop& lhs, const TramStop& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Line : public virtual ::Ice::Object
{
public:

    typedef LinePrx ProxyType;
    typedef LinePtr PointerType;

    virtual ~Line();

#ifdef ICE_CPP11_COMPILER
    Line() = default;
    Line(const Line&) = default;
    Line& operator=(const Line&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual TramList getTrams(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getTrams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StopList getStops(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getStops(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerTram(const TramPrx& tram, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerTram(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterTram(const TramPrx& tram, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterTram(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setStops(const StopList& sl, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setStops(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getName(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Line& lhs, const Line& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Line& lhs, const Line& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class LineFactory : public virtual ::Ice::Object
{
public:

    typedef LineFactoryPrx ProxyType;
    typedef LineFactoryPtr PointerType;

    virtual ~LineFactory();

#ifdef ICE_CPP11_COMPILER
    LineFactory() = default;
    LineFactory(const LineFactory&) = default;
    LineFactory& operator=(const LineFactory&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual LinePrx createLine(const ::std::string& name, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_createLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Double getLoad(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getLoad(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const LineFactory& lhs, const LineFactory& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const LineFactory& lhs, const LineFactory& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class StopFactory : public virtual ::Ice::Object
{
public:

    typedef StopFactoryPrx ProxyType;
    typedef StopFactoryPtr PointerType;

    virtual ~StopFactory();

#ifdef ICE_CPP11_COMPILER
    StopFactory() = default;
    StopFactory(const StopFactory&) = default;
    StopFactory& operator=(const StopFactory&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual StopPrx createStop(const ::std::string& name, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_createStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Double getLoad(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getLoad(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const StopFactory& lhs, const StopFactory& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const StopFactory& lhs, const StopFactory& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class MPK : public virtual ::Ice::Object
{
public:

    typedef MPKPrx ProxyType;
    typedef MPKPtr PointerType;

    virtual ~MPK();

#ifdef ICE_CPP11_COMPILER
    MPK() = default;
    MPK(const MPK&) = default;
    MPK& operator=(const MPK&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual TramStopPrx getTramStop(const ::std::string& name, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getTramStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerDepo(const DepoPrx& depo, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerDepo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterDepo(const DepoPrx& depo, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterDepo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DepoPrx getDepo(const ::std::string& name, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getDepo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DepoList getDepos(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getDepos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LineList getLines(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerLineFactory(const LineFactoryPrx& lf, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerLineFactory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterLineFactory(const LineFactoryPrx& lf, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterLineFactory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerStopFactory(const StopFactoryPrx& lf, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerStopFactory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterStopFactory(const StopFactoryPrx& lf, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterStopFactory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const MPK& lhs, const MPK& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MPK& lhs, const MPK& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Depo : public virtual ::Ice::Object
{
public:

    typedef DepoPrx ProxyType;
    typedef DepoPtr PointerType;

    virtual ~Depo();

#ifdef ICE_CPP11_COMPILER
    Depo() = default;
    Depo(const Depo&) = default;
    Depo& operator=(const Depo&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void TramOnline(const TramPrx& t, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_TramOnline(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void TramOffline(const TramPrx& t, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_TramOffline(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getName(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Depo& lhs, const Depo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Depo& lhs, const Depo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Tram : public virtual ::Ice::Object
{
public:

    typedef TramPrx ProxyType;
    typedef TramPtr PointerType;

    virtual ~Tram();

#ifdef ICE_CPP11_COMPILER
    Tram() = default;
    Tram(const Tram&) = default;
    Tram& operator=(const Tram&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual TramStopPrx getLocation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getLocation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LinePrx getLine(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setLine(const LinePrx& line, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StopList getNextStops(::Ice::Int howMany, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getNextStops(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void RegisterPassenger(const PassengerPrx& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RegisterPassenger(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UnregisterPassenger(const PassengerPrx& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UnregisterPassenger(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getStockNumber(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getStockNumber(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Tram& lhs, const Tram& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Tram& lhs, const Tram& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Passenger : public virtual ::Ice::Object
{
public:

    typedef PassengerPrx ProxyType;
    typedef PassengerPtr PointerType;

    virtual ~Passenger();

#ifdef ICE_CPP11_COMPILER
    Passenger() = default;
    Passenger(const Passenger&) = default;
    Passenger& operator=(const Passenger&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void updateTramInfo(const TramPrx& tram, const StopList& stops, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_updateTramInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void updateStopInfo(const StopPrx& stop, const TramList& trams, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_updateStopInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Passenger& lhs, const Passenger& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Passenger& lhs, const Passenger& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::SIP::Time>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::SIP::Time, S>
{
    static void write(S* ostr, const ::SIP::Time& v)
    {
        ostr->write(v.hour);
        ostr->write(v.minute);
    }
};

template<typename S>
struct StreamReader< ::SIP::Time, S>
{
    static void read(S* istr, ::SIP::Time& v)
    {
        istr->read(v.hour);
        istr->read(v.minute);
    }
};

template<>
struct StreamableTraits< ::SIP::StopInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::SIP::StopInfo, S>
{
    static void write(S* ostr, const ::SIP::StopInfo& v)
    {
        ostr->write(v.time);
        ostr->write(v.stop);
    }
};

template<typename S>
struct StreamReader< ::SIP::StopInfo, S>
{
    static void read(S* istr, ::SIP::StopInfo& v)
    {
        istr->read(v.time);
        istr->read(v.stop);
    }
};

template<>
struct StreamableTraits< ::SIP::TramInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::SIP::TramInfo, S>
{
    static void write(S* ostr, const ::SIP::TramInfo& v)
    {
        ostr->write(v.time);
        ostr->write(v.tram);
    }
};

template<typename S>
struct StreamReader< ::SIP::TramInfo, S>
{
    static void read(S* istr, ::SIP::TramInfo& v)
    {
        istr->read(v.time);
        istr->read(v.tram);
    }
};

template<>
struct StreamableTraits< ::SIP::DepoInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::SIP::DepoInfo, S>
{
    static void write(S* ostr, const ::SIP::DepoInfo& v)
    {
        ostr->write(v.name);
        ostr->write(v.stop);
    }
};

template<typename S>
struct StreamReader< ::SIP::DepoInfo, S>
{
    static void read(S* istr, ::SIP::DepoInfo& v)
    {
        istr->read(v.name);
        istr->read(v.stop);
    }
};

}
/// \endcond

namespace SIP
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::TramStop::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_getName.
 */
template<class T>
class CallbackNC_TramStop_getName : public Callback_TramStop_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TramStop_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramStopPrx proxy = TramStopPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_getName.
 */
template<class T> Callback_TramStop_getNamePtr
newCallback_TramStop_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_getName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_getName.
 */
template<class T> Callback_TramStop_getNamePtr
newCallback_TramStop_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_getName<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::TramStop::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_getName.
 */
template<class T, typename CT>
class Callback_TramStop_getName : public Callback_TramStop_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TramStop_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramStopPrx proxy = TramStopPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_getName.
 */
template<class T, typename CT> Callback_TramStop_getNamePtr
newCallback_TramStop_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_getName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_getName.
 */
template<class T, typename CT> Callback_TramStop_getNamePtr
newCallback_TramStop_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_getName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::TramStop::begin_getNextTrams.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_getNextTrams.
 */
template<class T>
class CallbackNC_TramStop_getNextTrams : public Callback_TramStop_getNextTrams_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TramList&);

    CallbackNC_TramStop_getNextTrams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramStopPrx proxy = TramStopPrx::uncheckedCast(result->getProxy());
        TramList ret;
        try
        {
            ret = proxy->end_getNextTrams(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_getNextTrams.
 */
template<class T> Callback_TramStop_getNextTramsPtr
newCallback_TramStop_getNextTrams(const IceUtil::Handle<T>& instance, void (T::*cb)(const TramList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_getNextTrams<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_getNextTrams.
 */
template<class T> Callback_TramStop_getNextTramsPtr
newCallback_TramStop_getNextTrams(T* instance, void (T::*cb)(const TramList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_getNextTrams<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::TramStop::begin_getNextTrams.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_getNextTrams.
 */
template<class T, typename CT>
class Callback_TramStop_getNextTrams : public Callback_TramStop_getNextTrams_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TramList&, const CT&);

    Callback_TramStop_getNextTrams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramStopPrx proxy = TramStopPrx::uncheckedCast(result->getProxy());
        TramList ret;
        try
        {
            ret = proxy->end_getNextTrams(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_getNextTrams.
 */
template<class T, typename CT> Callback_TramStop_getNextTramsPtr
newCallback_TramStop_getNextTrams(const IceUtil::Handle<T>& instance, void (T::*cb)(const TramList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_getNextTrams<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_getNextTrams.
 */
template<class T, typename CT> Callback_TramStop_getNextTramsPtr
newCallback_TramStop_getNextTrams(T* instance, void (T::*cb)(const TramList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_getNextTrams<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::TramStop::begin_RegisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_RegisterPassenger.
 */
template<class T>
class CallbackNC_TramStop_RegisterPassenger : public Callback_TramStop_RegisterPassenger_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TramStop_RegisterPassenger(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_RegisterPassenger.
 */
template<class T> Callback_TramStop_RegisterPassengerPtr
newCallback_TramStop_RegisterPassenger(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_RegisterPassenger<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_RegisterPassenger.
 */
template<class T> Callback_TramStop_RegisterPassengerPtr
newCallback_TramStop_RegisterPassenger(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_RegisterPassenger<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_RegisterPassenger.
 */
template<class T> Callback_TramStop_RegisterPassengerPtr
newCallback_TramStop_RegisterPassenger(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_RegisterPassenger<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_RegisterPassenger.
 */
template<class T> Callback_TramStop_RegisterPassengerPtr
newCallback_TramStop_RegisterPassenger(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_RegisterPassenger<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::TramStop::begin_RegisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_RegisterPassenger.
 */
template<class T, typename CT>
class Callback_TramStop_RegisterPassenger : public Callback_TramStop_RegisterPassenger_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TramStop_RegisterPassenger(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_RegisterPassenger.
 */
template<class T, typename CT> Callback_TramStop_RegisterPassengerPtr
newCallback_TramStop_RegisterPassenger(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_RegisterPassenger<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_RegisterPassenger.
 */
template<class T, typename CT> Callback_TramStop_RegisterPassengerPtr
newCallback_TramStop_RegisterPassenger(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_RegisterPassenger<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_RegisterPassenger.
 */
template<class T, typename CT> Callback_TramStop_RegisterPassengerPtr
newCallback_TramStop_RegisterPassenger(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_RegisterPassenger<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_RegisterPassenger.
 */
template<class T, typename CT> Callback_TramStop_RegisterPassengerPtr
newCallback_TramStop_RegisterPassenger(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_RegisterPassenger<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_UnregisterPassenger.
 */
template<class T>
class CallbackNC_TramStop_UnregisterPassenger : public Callback_TramStop_UnregisterPassenger_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TramStop_UnregisterPassenger(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 */
template<class T> Callback_TramStop_UnregisterPassengerPtr
newCallback_TramStop_UnregisterPassenger(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_UnregisterPassenger<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 */
template<class T> Callback_TramStop_UnregisterPassengerPtr
newCallback_TramStop_UnregisterPassenger(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_UnregisterPassenger<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 */
template<class T> Callback_TramStop_UnregisterPassengerPtr
newCallback_TramStop_UnregisterPassenger(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_UnregisterPassenger<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 */
template<class T> Callback_TramStop_UnregisterPassengerPtr
newCallback_TramStop_UnregisterPassenger(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_UnregisterPassenger<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_UnregisterPassenger.
 */
template<class T, typename CT>
class Callback_TramStop_UnregisterPassenger : public Callback_TramStop_UnregisterPassenger_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TramStop_UnregisterPassenger(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 */
template<class T, typename CT> Callback_TramStop_UnregisterPassengerPtr
newCallback_TramStop_UnregisterPassenger(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_UnregisterPassenger<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 */
template<class T, typename CT> Callback_TramStop_UnregisterPassengerPtr
newCallback_TramStop_UnregisterPassenger(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_UnregisterPassenger<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 */
template<class T, typename CT> Callback_TramStop_UnregisterPassengerPtr
newCallback_TramStop_UnregisterPassenger(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_UnregisterPassenger<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UnregisterPassenger.
 */
template<class T, typename CT> Callback_TramStop_UnregisterPassengerPtr
newCallback_TramStop_UnregisterPassenger(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_UnregisterPassenger<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_UpdateTramInfo.
 */
template<class T>
class CallbackNC_TramStop_UpdateTramInfo : public Callback_TramStop_UpdateTramInfo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TramStop_UpdateTramInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 */
template<class T> Callback_TramStop_UpdateTramInfoPtr
newCallback_TramStop_UpdateTramInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_UpdateTramInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 */
template<class T> Callback_TramStop_UpdateTramInfoPtr
newCallback_TramStop_UpdateTramInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_UpdateTramInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 */
template<class T> Callback_TramStop_UpdateTramInfoPtr
newCallback_TramStop_UpdateTramInfo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_UpdateTramInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 */
template<class T> Callback_TramStop_UpdateTramInfoPtr
newCallback_TramStop_UpdateTramInfo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TramStop_UpdateTramInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_TramStop_UpdateTramInfo.
 */
template<class T, typename CT>
class Callback_TramStop_UpdateTramInfo : public Callback_TramStop_UpdateTramInfo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TramStop_UpdateTramInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 */
template<class T, typename CT> Callback_TramStop_UpdateTramInfoPtr
newCallback_TramStop_UpdateTramInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_UpdateTramInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 */
template<class T, typename CT> Callback_TramStop_UpdateTramInfoPtr
newCallback_TramStop_UpdateTramInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_UpdateTramInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 */
template<class T, typename CT> Callback_TramStop_UpdateTramInfoPtr
newCallback_TramStop_UpdateTramInfo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_UpdateTramInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::TramStop::begin_UpdateTramInfo.
 */
template<class T, typename CT> Callback_TramStop_UpdateTramInfoPtr
newCallback_TramStop_UpdateTramInfo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TramStop_UpdateTramInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Line::begin_getTrams.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getTrams.
 */
template<class T>
class CallbackNC_Line_getTrams : public Callback_Line_getTrams_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TramList&);

    CallbackNC_Line_getTrams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        TramList ret;
        try
        {
            ret = proxy->end_getTrams(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getTrams.
 */
template<class T> Callback_Line_getTramsPtr
newCallback_Line_getTrams(const IceUtil::Handle<T>& instance, void (T::*cb)(const TramList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getTrams<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getTrams.
 */
template<class T> Callback_Line_getTramsPtr
newCallback_Line_getTrams(T* instance, void (T::*cb)(const TramList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getTrams<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Line::begin_getTrams.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getTrams.
 */
template<class T, typename CT>
class Callback_Line_getTrams : public Callback_Line_getTrams_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TramList&, const CT&);

    Callback_Line_getTrams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        TramList ret;
        try
        {
            ret = proxy->end_getTrams(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getTrams.
 */
template<class T, typename CT> Callback_Line_getTramsPtr
newCallback_Line_getTrams(const IceUtil::Handle<T>& instance, void (T::*cb)(const TramList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getTrams<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getTrams.
 */
template<class T, typename CT> Callback_Line_getTramsPtr
newCallback_Line_getTrams(T* instance, void (T::*cb)(const TramList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getTrams<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Line::begin_getStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getStops.
 */
template<class T>
class CallbackNC_Line_getStops : public Callback_Line_getStops_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StopList&);

    CallbackNC_Line_getStops(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        StopList ret;
        try
        {
            ret = proxy->end_getStops(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getStops.
 */
template<class T> Callback_Line_getStopsPtr
newCallback_Line_getStops(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getStops<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getStops.
 */
template<class T> Callback_Line_getStopsPtr
newCallback_Line_getStops(T* instance, void (T::*cb)(const StopList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getStops<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Line::begin_getStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getStops.
 */
template<class T, typename CT>
class Callback_Line_getStops : public Callback_Line_getStops_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StopList&, const CT&);

    Callback_Line_getStops(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        StopList ret;
        try
        {
            ret = proxy->end_getStops(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getStops.
 */
template<class T, typename CT> Callback_Line_getStopsPtr
newCallback_Line_getStops(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getStops<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getStops.
 */
template<class T, typename CT> Callback_Line_getStopsPtr
newCallback_Line_getStops(T* instance, void (T::*cb)(const StopList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getStops<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Line::begin_registerTram.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_registerTram.
 */
template<class T>
class CallbackNC_Line_registerTram : public Callback_Line_registerTram_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Line_registerTram(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_registerTram.
 */
template<class T> Callback_Line_registerTramPtr
newCallback_Line_registerTram(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_registerTram<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_registerTram.
 */
template<class T> Callback_Line_registerTramPtr
newCallback_Line_registerTram(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_registerTram<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_registerTram.
 */
template<class T> Callback_Line_registerTramPtr
newCallback_Line_registerTram(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_registerTram<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_registerTram.
 */
template<class T> Callback_Line_registerTramPtr
newCallback_Line_registerTram(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_registerTram<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Line::begin_registerTram.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_registerTram.
 */
template<class T, typename CT>
class Callback_Line_registerTram : public Callback_Line_registerTram_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Line_registerTram(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_registerTram.
 */
template<class T, typename CT> Callback_Line_registerTramPtr
newCallback_Line_registerTram(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_registerTram<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_registerTram.
 */
template<class T, typename CT> Callback_Line_registerTramPtr
newCallback_Line_registerTram(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_registerTram<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_registerTram.
 */
template<class T, typename CT> Callback_Line_registerTramPtr
newCallback_Line_registerTram(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_registerTram<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_registerTram.
 */
template<class T, typename CT> Callback_Line_registerTramPtr
newCallback_Line_registerTram(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_registerTram<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Line::begin_unregisterTram.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_unregisterTram.
 */
template<class T>
class CallbackNC_Line_unregisterTram : public Callback_Line_unregisterTram_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Line_unregisterTram(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_unregisterTram.
 */
template<class T> Callback_Line_unregisterTramPtr
newCallback_Line_unregisterTram(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_unregisterTram<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_unregisterTram.
 */
template<class T> Callback_Line_unregisterTramPtr
newCallback_Line_unregisterTram(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_unregisterTram<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_unregisterTram.
 */
template<class T> Callback_Line_unregisterTramPtr
newCallback_Line_unregisterTram(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_unregisterTram<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_unregisterTram.
 */
template<class T> Callback_Line_unregisterTramPtr
newCallback_Line_unregisterTram(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_unregisterTram<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Line::begin_unregisterTram.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_unregisterTram.
 */
template<class T, typename CT>
class Callback_Line_unregisterTram : public Callback_Line_unregisterTram_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Line_unregisterTram(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_unregisterTram.
 */
template<class T, typename CT> Callback_Line_unregisterTramPtr
newCallback_Line_unregisterTram(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_unregisterTram<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_unregisterTram.
 */
template<class T, typename CT> Callback_Line_unregisterTramPtr
newCallback_Line_unregisterTram(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_unregisterTram<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_unregisterTram.
 */
template<class T, typename CT> Callback_Line_unregisterTramPtr
newCallback_Line_unregisterTram(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_unregisterTram<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_unregisterTram.
 */
template<class T, typename CT> Callback_Line_unregisterTramPtr
newCallback_Line_unregisterTram(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_unregisterTram<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Line::begin_setStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_setStops.
 */
template<class T>
class CallbackNC_Line_setStops : public Callback_Line_setStops_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Line_setStops(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_setStops.
 */
template<class T> Callback_Line_setStopsPtr
newCallback_Line_setStops(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_setStops<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_setStops.
 */
template<class T> Callback_Line_setStopsPtr
newCallback_Line_setStops(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_setStops<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_setStops.
 */
template<class T> Callback_Line_setStopsPtr
newCallback_Line_setStops(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_setStops<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_setStops.
 */
template<class T> Callback_Line_setStopsPtr
newCallback_Line_setStops(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_setStops<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Line::begin_setStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_setStops.
 */
template<class T, typename CT>
class Callback_Line_setStops : public Callback_Line_setStops_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Line_setStops(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_setStops.
 */
template<class T, typename CT> Callback_Line_setStopsPtr
newCallback_Line_setStops(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_setStops<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_setStops.
 */
template<class T, typename CT> Callback_Line_setStopsPtr
newCallback_Line_setStops(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_setStops<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_setStops.
 */
template<class T, typename CT> Callback_Line_setStopsPtr
newCallback_Line_setStops(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_setStops<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_setStops.
 */
template<class T, typename CT> Callback_Line_setStopsPtr
newCallback_Line_setStops(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_setStops<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Line::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getName.
 */
template<class T>
class CallbackNC_Line_getName : public Callback_Line_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Line_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getName.
 */
template<class T> Callback_Line_getNamePtr
newCallback_Line_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getName.
 */
template<class T> Callback_Line_getNamePtr
newCallback_Line_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getName<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Line::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_Line_getName.
 */
template<class T, typename CT>
class Callback_Line_getName : public Callback_Line_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Line_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getName.
 */
template<class T, typename CT> Callback_Line_getNamePtr
newCallback_Line_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Line::begin_getName.
 */
template<class T, typename CT> Callback_Line_getNamePtr
newCallback_Line_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::LineFactory::begin_createLine.
 * Create a wrapper instance by calling ::SIP::newCallback_LineFactory_createLine.
 */
template<class T>
class CallbackNC_LineFactory_createLine : public Callback_LineFactory_createLine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LinePrx&);

    CallbackNC_LineFactory_createLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LineFactoryPrx proxy = LineFactoryPrx::uncheckedCast(result->getProxy());
        LinePrx ret;
        try
        {
            ret = proxy->end_createLine(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::LineFactory::begin_createLine.
 */
template<class T> Callback_LineFactory_createLinePtr
newCallback_LineFactory_createLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const LinePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LineFactory_createLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::LineFactory::begin_createLine.
 */
template<class T> Callback_LineFactory_createLinePtr
newCallback_LineFactory_createLine(T* instance, void (T::*cb)(const LinePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LineFactory_createLine<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::LineFactory::begin_createLine.
 * Create a wrapper instance by calling ::SIP::newCallback_LineFactory_createLine.
 */
template<class T, typename CT>
class Callback_LineFactory_createLine : public Callback_LineFactory_createLine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LinePrx&, const CT&);

    Callback_LineFactory_createLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LineFactoryPrx proxy = LineFactoryPrx::uncheckedCast(result->getProxy());
        LinePrx ret;
        try
        {
            ret = proxy->end_createLine(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::LineFactory::begin_createLine.
 */
template<class T, typename CT> Callback_LineFactory_createLinePtr
newCallback_LineFactory_createLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const LinePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LineFactory_createLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::LineFactory::begin_createLine.
 */
template<class T, typename CT> Callback_LineFactory_createLinePtr
newCallback_LineFactory_createLine(T* instance, void (T::*cb)(const LinePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LineFactory_createLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::LineFactory::begin_getLoad.
 * Create a wrapper instance by calling ::SIP::newCallback_LineFactory_getLoad.
 */
template<class T>
class CallbackNC_LineFactory_getLoad : public Callback_LineFactory_getLoad_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Double);

    CallbackNC_LineFactory_getLoad(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LineFactoryPrx proxy = LineFactoryPrx::uncheckedCast(result->getProxy());
        ::Ice::Double ret;
        try
        {
            ret = proxy->end_getLoad(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::LineFactory::begin_getLoad.
 */
template<class T> Callback_LineFactory_getLoadPtr
newCallback_LineFactory_getLoad(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LineFactory_getLoad<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::LineFactory::begin_getLoad.
 */
template<class T> Callback_LineFactory_getLoadPtr
newCallback_LineFactory_getLoad(T* instance, void (T::*cb)(::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LineFactory_getLoad<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::LineFactory::begin_getLoad.
 * Create a wrapper instance by calling ::SIP::newCallback_LineFactory_getLoad.
 */
template<class T, typename CT>
class Callback_LineFactory_getLoad : public Callback_LineFactory_getLoad_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Double, const CT&);

    Callback_LineFactory_getLoad(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LineFactoryPrx proxy = LineFactoryPrx::uncheckedCast(result->getProxy());
        ::Ice::Double ret;
        try
        {
            ret = proxy->end_getLoad(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::LineFactory::begin_getLoad.
 */
template<class T, typename CT> Callback_LineFactory_getLoadPtr
newCallback_LineFactory_getLoad(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LineFactory_getLoad<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::LineFactory::begin_getLoad.
 */
template<class T, typename CT> Callback_LineFactory_getLoadPtr
newCallback_LineFactory_getLoad(T* instance, void (T::*cb)(::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LineFactory_getLoad<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::StopFactory::begin_createStop.
 * Create a wrapper instance by calling ::SIP::newCallback_StopFactory_createStop.
 */
template<class T>
class CallbackNC_StopFactory_createStop : public Callback_StopFactory_createStop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StopPrx&);

    CallbackNC_StopFactory_createStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopFactoryPrx proxy = StopFactoryPrx::uncheckedCast(result->getProxy());
        StopPrx ret;
        try
        {
            ret = proxy->end_createStop(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::StopFactory::begin_createStop.
 */
template<class T> Callback_StopFactory_createStopPtr
newCallback_StopFactory_createStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StopFactory_createStop<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::StopFactory::begin_createStop.
 */
template<class T> Callback_StopFactory_createStopPtr
newCallback_StopFactory_createStop(T* instance, void (T::*cb)(const StopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StopFactory_createStop<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::StopFactory::begin_createStop.
 * Create a wrapper instance by calling ::SIP::newCallback_StopFactory_createStop.
 */
template<class T, typename CT>
class Callback_StopFactory_createStop : public Callback_StopFactory_createStop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StopPrx&, const CT&);

    Callback_StopFactory_createStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopFactoryPrx proxy = StopFactoryPrx::uncheckedCast(result->getProxy());
        StopPrx ret;
        try
        {
            ret = proxy->end_createStop(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::StopFactory::begin_createStop.
 */
template<class T, typename CT> Callback_StopFactory_createStopPtr
newCallback_StopFactory_createStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StopFactory_createStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::StopFactory::begin_createStop.
 */
template<class T, typename CT> Callback_StopFactory_createStopPtr
newCallback_StopFactory_createStop(T* instance, void (T::*cb)(const StopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StopFactory_createStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::StopFactory::begin_getLoad.
 * Create a wrapper instance by calling ::SIP::newCallback_StopFactory_getLoad.
 */
template<class T>
class CallbackNC_StopFactory_getLoad : public Callback_StopFactory_getLoad_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Double);

    CallbackNC_StopFactory_getLoad(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopFactoryPrx proxy = StopFactoryPrx::uncheckedCast(result->getProxy());
        ::Ice::Double ret;
        try
        {
            ret = proxy->end_getLoad(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::StopFactory::begin_getLoad.
 */
template<class T> Callback_StopFactory_getLoadPtr
newCallback_StopFactory_getLoad(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StopFactory_getLoad<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::StopFactory::begin_getLoad.
 */
template<class T> Callback_StopFactory_getLoadPtr
newCallback_StopFactory_getLoad(T* instance, void (T::*cb)(::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StopFactory_getLoad<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::StopFactory::begin_getLoad.
 * Create a wrapper instance by calling ::SIP::newCallback_StopFactory_getLoad.
 */
template<class T, typename CT>
class Callback_StopFactory_getLoad : public Callback_StopFactory_getLoad_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Double, const CT&);

    Callback_StopFactory_getLoad(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopFactoryPrx proxy = StopFactoryPrx::uncheckedCast(result->getProxy());
        ::Ice::Double ret;
        try
        {
            ret = proxy->end_getLoad(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::StopFactory::begin_getLoad.
 */
template<class T, typename CT> Callback_StopFactory_getLoadPtr
newCallback_StopFactory_getLoad(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StopFactory_getLoad<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::StopFactory::begin_getLoad.
 */
template<class T, typename CT> Callback_StopFactory_getLoadPtr
newCallback_StopFactory_getLoad(T* instance, void (T::*cb)(::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StopFactory_getLoad<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_getTramStop.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getTramStop.
 */
template<class T>
class CallbackNC_MPK_getTramStop : public Callback_MPK_getTramStop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TramStopPrx&);

    CallbackNC_MPK_getTramStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MPKPrx proxy = MPKPrx::uncheckedCast(result->getProxy());
        TramStopPrx ret;
        try
        {
            ret = proxy->end_getTramStop(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getTramStop.
 */
template<class T> Callback_MPK_getTramStopPtr
newCallback_MPK_getTramStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const TramStopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_getTramStop<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getTramStop.
 */
template<class T> Callback_MPK_getTramStopPtr
newCallback_MPK_getTramStop(T* instance, void (T::*cb)(const TramStopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_getTramStop<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_getTramStop.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getTramStop.
 */
template<class T, typename CT>
class Callback_MPK_getTramStop : public Callback_MPK_getTramStop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TramStopPrx&, const CT&);

    Callback_MPK_getTramStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MPKPrx proxy = MPKPrx::uncheckedCast(result->getProxy());
        TramStopPrx ret;
        try
        {
            ret = proxy->end_getTramStop(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getTramStop.
 */
template<class T, typename CT> Callback_MPK_getTramStopPtr
newCallback_MPK_getTramStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const TramStopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_getTramStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getTramStop.
 */
template<class T, typename CT> Callback_MPK_getTramStopPtr
newCallback_MPK_getTramStop(T* instance, void (T::*cb)(const TramStopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_getTramStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_registerDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerDepo.
 */
template<class T>
class CallbackNC_MPK_registerDepo : public Callback_MPK_registerDepo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MPK_registerDepo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerDepo.
 */
template<class T> Callback_MPK_registerDepoPtr
newCallback_MPK_registerDepo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerDepo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerDepo.
 */
template<class T> Callback_MPK_registerDepoPtr
newCallback_MPK_registerDepo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerDepo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerDepo.
 */
template<class T> Callback_MPK_registerDepoPtr
newCallback_MPK_registerDepo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerDepo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerDepo.
 */
template<class T> Callback_MPK_registerDepoPtr
newCallback_MPK_registerDepo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerDepo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_registerDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerDepo.
 */
template<class T, typename CT>
class Callback_MPK_registerDepo : public Callback_MPK_registerDepo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MPK_registerDepo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerDepo.
 */
template<class T, typename CT> Callback_MPK_registerDepoPtr
newCallback_MPK_registerDepo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerDepo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerDepo.
 */
template<class T, typename CT> Callback_MPK_registerDepoPtr
newCallback_MPK_registerDepo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerDepo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerDepo.
 */
template<class T, typename CT> Callback_MPK_registerDepoPtr
newCallback_MPK_registerDepo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerDepo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerDepo.
 */
template<class T, typename CT> Callback_MPK_registerDepoPtr
newCallback_MPK_registerDepo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerDepo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_unregisterDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterDepo.
 */
template<class T>
class CallbackNC_MPK_unregisterDepo : public Callback_MPK_unregisterDepo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MPK_unregisterDepo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterDepo.
 */
template<class T> Callback_MPK_unregisterDepoPtr
newCallback_MPK_unregisterDepo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterDepo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterDepo.
 */
template<class T> Callback_MPK_unregisterDepoPtr
newCallback_MPK_unregisterDepo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterDepo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterDepo.
 */
template<class T> Callback_MPK_unregisterDepoPtr
newCallback_MPK_unregisterDepo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterDepo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterDepo.
 */
template<class T> Callback_MPK_unregisterDepoPtr
newCallback_MPK_unregisterDepo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterDepo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_unregisterDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterDepo.
 */
template<class T, typename CT>
class Callback_MPK_unregisterDepo : public Callback_MPK_unregisterDepo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MPK_unregisterDepo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterDepo.
 */
template<class T, typename CT> Callback_MPK_unregisterDepoPtr
newCallback_MPK_unregisterDepo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterDepo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterDepo.
 */
template<class T, typename CT> Callback_MPK_unregisterDepoPtr
newCallback_MPK_unregisterDepo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterDepo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterDepo.
 */
template<class T, typename CT> Callback_MPK_unregisterDepoPtr
newCallback_MPK_unregisterDepo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterDepo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterDepo.
 */
template<class T, typename CT> Callback_MPK_unregisterDepoPtr
newCallback_MPK_unregisterDepo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterDepo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_getDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getDepo.
 */
template<class T>
class CallbackNC_MPK_getDepo : public Callback_MPK_getDepo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DepoPrx&);

    CallbackNC_MPK_getDepo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MPKPrx proxy = MPKPrx::uncheckedCast(result->getProxy());
        DepoPrx ret;
        try
        {
            ret = proxy->end_getDepo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getDepo.
 */
template<class T> Callback_MPK_getDepoPtr
newCallback_MPK_getDepo(const IceUtil::Handle<T>& instance, void (T::*cb)(const DepoPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_getDepo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getDepo.
 */
template<class T> Callback_MPK_getDepoPtr
newCallback_MPK_getDepo(T* instance, void (T::*cb)(const DepoPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_getDepo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_getDepo.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getDepo.
 */
template<class T, typename CT>
class Callback_MPK_getDepo : public Callback_MPK_getDepo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DepoPrx&, const CT&);

    Callback_MPK_getDepo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MPKPrx proxy = MPKPrx::uncheckedCast(result->getProxy());
        DepoPrx ret;
        try
        {
            ret = proxy->end_getDepo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getDepo.
 */
template<class T, typename CT> Callback_MPK_getDepoPtr
newCallback_MPK_getDepo(const IceUtil::Handle<T>& instance, void (T::*cb)(const DepoPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_getDepo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getDepo.
 */
template<class T, typename CT> Callback_MPK_getDepoPtr
newCallback_MPK_getDepo(T* instance, void (T::*cb)(const DepoPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_getDepo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_getDepos.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getDepos.
 */
template<class T>
class CallbackNC_MPK_getDepos : public Callback_MPK_getDepos_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DepoList&);

    CallbackNC_MPK_getDepos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MPKPrx proxy = MPKPrx::uncheckedCast(result->getProxy());
        DepoList ret;
        try
        {
            ret = proxy->end_getDepos(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getDepos.
 */
template<class T> Callback_MPK_getDeposPtr
newCallback_MPK_getDepos(const IceUtil::Handle<T>& instance, void (T::*cb)(const DepoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_getDepos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getDepos.
 */
template<class T> Callback_MPK_getDeposPtr
newCallback_MPK_getDepos(T* instance, void (T::*cb)(const DepoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_getDepos<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_getDepos.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getDepos.
 */
template<class T, typename CT>
class Callback_MPK_getDepos : public Callback_MPK_getDepos_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DepoList&, const CT&);

    Callback_MPK_getDepos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MPKPrx proxy = MPKPrx::uncheckedCast(result->getProxy());
        DepoList ret;
        try
        {
            ret = proxy->end_getDepos(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getDepos.
 */
template<class T, typename CT> Callback_MPK_getDeposPtr
newCallback_MPK_getDepos(const IceUtil::Handle<T>& instance, void (T::*cb)(const DepoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_getDepos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getDepos.
 */
template<class T, typename CT> Callback_MPK_getDeposPtr
newCallback_MPK_getDepos(T* instance, void (T::*cb)(const DepoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_getDepos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_getLines.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getLines.
 */
template<class T>
class CallbackNC_MPK_getLines : public Callback_MPK_getLines_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LineList&);

    CallbackNC_MPK_getLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MPKPrx proxy = MPKPrx::uncheckedCast(result->getProxy());
        LineList ret;
        try
        {
            ret = proxy->end_getLines(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getLines.
 */
template<class T> Callback_MPK_getLinesPtr
newCallback_MPK_getLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const LineList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_getLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getLines.
 */
template<class T> Callback_MPK_getLinesPtr
newCallback_MPK_getLines(T* instance, void (T::*cb)(const LineList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_getLines<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_getLines.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_getLines.
 */
template<class T, typename CT>
class Callback_MPK_getLines : public Callback_MPK_getLines_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LineList&, const CT&);

    Callback_MPK_getLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MPKPrx proxy = MPKPrx::uncheckedCast(result->getProxy());
        LineList ret;
        try
        {
            ret = proxy->end_getLines(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getLines.
 */
template<class T, typename CT> Callback_MPK_getLinesPtr
newCallback_MPK_getLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const LineList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_getLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_getLines.
 */
template<class T, typename CT> Callback_MPK_getLinesPtr
newCallback_MPK_getLines(T* instance, void (T::*cb)(const LineList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_getLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_registerLineFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerLineFactory.
 */
template<class T>
class CallbackNC_MPK_registerLineFactory : public Callback_MPK_registerLineFactory_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MPK_registerLineFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerLineFactory.
 */
template<class T> Callback_MPK_registerLineFactoryPtr
newCallback_MPK_registerLineFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerLineFactory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerLineFactory.
 */
template<class T> Callback_MPK_registerLineFactoryPtr
newCallback_MPK_registerLineFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerLineFactory<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerLineFactory.
 */
template<class T> Callback_MPK_registerLineFactoryPtr
newCallback_MPK_registerLineFactory(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerLineFactory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerLineFactory.
 */
template<class T> Callback_MPK_registerLineFactoryPtr
newCallback_MPK_registerLineFactory(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerLineFactory<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_registerLineFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerLineFactory.
 */
template<class T, typename CT>
class Callback_MPK_registerLineFactory : public Callback_MPK_registerLineFactory_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MPK_registerLineFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerLineFactory.
 */
template<class T, typename CT> Callback_MPK_registerLineFactoryPtr
newCallback_MPK_registerLineFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerLineFactory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerLineFactory.
 */
template<class T, typename CT> Callback_MPK_registerLineFactoryPtr
newCallback_MPK_registerLineFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerLineFactory<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerLineFactory.
 */
template<class T, typename CT> Callback_MPK_registerLineFactoryPtr
newCallback_MPK_registerLineFactory(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerLineFactory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerLineFactory.
 */
template<class T, typename CT> Callback_MPK_registerLineFactoryPtr
newCallback_MPK_registerLineFactory(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerLineFactory<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_unregisterLineFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterLineFactory.
 */
template<class T>
class CallbackNC_MPK_unregisterLineFactory : public Callback_MPK_unregisterLineFactory_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MPK_unregisterLineFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterLineFactory.
 */
template<class T> Callback_MPK_unregisterLineFactoryPtr
newCallback_MPK_unregisterLineFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterLineFactory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterLineFactory.
 */
template<class T> Callback_MPK_unregisterLineFactoryPtr
newCallback_MPK_unregisterLineFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterLineFactory<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterLineFactory.
 */
template<class T> Callback_MPK_unregisterLineFactoryPtr
newCallback_MPK_unregisterLineFactory(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterLineFactory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterLineFactory.
 */
template<class T> Callback_MPK_unregisterLineFactoryPtr
newCallback_MPK_unregisterLineFactory(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterLineFactory<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_unregisterLineFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterLineFactory.
 */
template<class T, typename CT>
class Callback_MPK_unregisterLineFactory : public Callback_MPK_unregisterLineFactory_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MPK_unregisterLineFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterLineFactory.
 */
template<class T, typename CT> Callback_MPK_unregisterLineFactoryPtr
newCallback_MPK_unregisterLineFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterLineFactory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterLineFactory.
 */
template<class T, typename CT> Callback_MPK_unregisterLineFactoryPtr
newCallback_MPK_unregisterLineFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterLineFactory<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterLineFactory.
 */
template<class T, typename CT> Callback_MPK_unregisterLineFactoryPtr
newCallback_MPK_unregisterLineFactory(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterLineFactory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterLineFactory.
 */
template<class T, typename CT> Callback_MPK_unregisterLineFactoryPtr
newCallback_MPK_unregisterLineFactory(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterLineFactory<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_registerStopFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerStopFactory.
 */
template<class T>
class CallbackNC_MPK_registerStopFactory : public Callback_MPK_registerStopFactory_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MPK_registerStopFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerStopFactory.
 */
template<class T> Callback_MPK_registerStopFactoryPtr
newCallback_MPK_registerStopFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerStopFactory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerStopFactory.
 */
template<class T> Callback_MPK_registerStopFactoryPtr
newCallback_MPK_registerStopFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerStopFactory<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerStopFactory.
 */
template<class T> Callback_MPK_registerStopFactoryPtr
newCallback_MPK_registerStopFactory(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerStopFactory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerStopFactory.
 */
template<class T> Callback_MPK_registerStopFactoryPtr
newCallback_MPK_registerStopFactory(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_registerStopFactory<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_registerStopFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_registerStopFactory.
 */
template<class T, typename CT>
class Callback_MPK_registerStopFactory : public Callback_MPK_registerStopFactory_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MPK_registerStopFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerStopFactory.
 */
template<class T, typename CT> Callback_MPK_registerStopFactoryPtr
newCallback_MPK_registerStopFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerStopFactory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerStopFactory.
 */
template<class T, typename CT> Callback_MPK_registerStopFactoryPtr
newCallback_MPK_registerStopFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerStopFactory<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerStopFactory.
 */
template<class T, typename CT> Callback_MPK_registerStopFactoryPtr
newCallback_MPK_registerStopFactory(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerStopFactory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_registerStopFactory.
 */
template<class T, typename CT> Callback_MPK_registerStopFactoryPtr
newCallback_MPK_registerStopFactory(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_registerStopFactory<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::MPK::begin_unregisterStopFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterStopFactory.
 */
template<class T>
class CallbackNC_MPK_unregisterStopFactory : public Callback_MPK_unregisterStopFactory_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MPK_unregisterStopFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterStopFactory.
 */
template<class T> Callback_MPK_unregisterStopFactoryPtr
newCallback_MPK_unregisterStopFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterStopFactory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterStopFactory.
 */
template<class T> Callback_MPK_unregisterStopFactoryPtr
newCallback_MPK_unregisterStopFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterStopFactory<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterStopFactory.
 */
template<class T> Callback_MPK_unregisterStopFactoryPtr
newCallback_MPK_unregisterStopFactory(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterStopFactory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterStopFactory.
 */
template<class T> Callback_MPK_unregisterStopFactoryPtr
newCallback_MPK_unregisterStopFactory(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MPK_unregisterStopFactory<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::MPK::begin_unregisterStopFactory.
 * Create a wrapper instance by calling ::SIP::newCallback_MPK_unregisterStopFactory.
 */
template<class T, typename CT>
class Callback_MPK_unregisterStopFactory : public Callback_MPK_unregisterStopFactory_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MPK_unregisterStopFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterStopFactory.
 */
template<class T, typename CT> Callback_MPK_unregisterStopFactoryPtr
newCallback_MPK_unregisterStopFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterStopFactory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterStopFactory.
 */
template<class T, typename CT> Callback_MPK_unregisterStopFactoryPtr
newCallback_MPK_unregisterStopFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterStopFactory<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterStopFactory.
 */
template<class T, typename CT> Callback_MPK_unregisterStopFactoryPtr
newCallback_MPK_unregisterStopFactory(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterStopFactory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::MPK::begin_unregisterStopFactory.
 */
template<class T, typename CT> Callback_MPK_unregisterStopFactoryPtr
newCallback_MPK_unregisterStopFactory(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MPK_unregisterStopFactory<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Depo::begin_TramOnline.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_TramOnline.
 */
template<class T>
class CallbackNC_Depo_TramOnline : public Callback_Depo_TramOnline_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Depo_TramOnline(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOnline.
 */
template<class T> Callback_Depo_TramOnlinePtr
newCallback_Depo_TramOnline(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_TramOnline<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOnline.
 */
template<class T> Callback_Depo_TramOnlinePtr
newCallback_Depo_TramOnline(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_TramOnline<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOnline.
 */
template<class T> Callback_Depo_TramOnlinePtr
newCallback_Depo_TramOnline(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_TramOnline<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOnline.
 */
template<class T> Callback_Depo_TramOnlinePtr
newCallback_Depo_TramOnline(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_TramOnline<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Depo::begin_TramOnline.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_TramOnline.
 */
template<class T, typename CT>
class Callback_Depo_TramOnline : public Callback_Depo_TramOnline_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Depo_TramOnline(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOnline.
 */
template<class T, typename CT> Callback_Depo_TramOnlinePtr
newCallback_Depo_TramOnline(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_TramOnline<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOnline.
 */
template<class T, typename CT> Callback_Depo_TramOnlinePtr
newCallback_Depo_TramOnline(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_TramOnline<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOnline.
 */
template<class T, typename CT> Callback_Depo_TramOnlinePtr
newCallback_Depo_TramOnline(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_TramOnline<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOnline.
 */
template<class T, typename CT> Callback_Depo_TramOnlinePtr
newCallback_Depo_TramOnline(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_TramOnline<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Depo::begin_TramOffline.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_TramOffline.
 */
template<class T>
class CallbackNC_Depo_TramOffline : public Callback_Depo_TramOffline_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Depo_TramOffline(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOffline.
 */
template<class T> Callback_Depo_TramOfflinePtr
newCallback_Depo_TramOffline(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_TramOffline<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOffline.
 */
template<class T> Callback_Depo_TramOfflinePtr
newCallback_Depo_TramOffline(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_TramOffline<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOffline.
 */
template<class T> Callback_Depo_TramOfflinePtr
newCallback_Depo_TramOffline(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_TramOffline<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOffline.
 */
template<class T> Callback_Depo_TramOfflinePtr
newCallback_Depo_TramOffline(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_TramOffline<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Depo::begin_TramOffline.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_TramOffline.
 */
template<class T, typename CT>
class Callback_Depo_TramOffline : public Callback_Depo_TramOffline_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Depo_TramOffline(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOffline.
 */
template<class T, typename CT> Callback_Depo_TramOfflinePtr
newCallback_Depo_TramOffline(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_TramOffline<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOffline.
 */
template<class T, typename CT> Callback_Depo_TramOfflinePtr
newCallback_Depo_TramOffline(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_TramOffline<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOffline.
 */
template<class T, typename CT> Callback_Depo_TramOfflinePtr
newCallback_Depo_TramOffline(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_TramOffline<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_TramOffline.
 */
template<class T, typename CT> Callback_Depo_TramOfflinePtr
newCallback_Depo_TramOffline(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_TramOffline<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Depo::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_getName.
 */
template<class T>
class CallbackNC_Depo_getName : public Callback_Depo_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Depo_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DepoPrx proxy = DepoPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_getName.
 */
template<class T> Callback_Depo_getNamePtr
newCallback_Depo_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_getName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_getName.
 */
template<class T> Callback_Depo_getNamePtr
newCallback_Depo_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Depo_getName<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Depo::begin_getName.
 * Create a wrapper instance by calling ::SIP::newCallback_Depo_getName.
 */
template<class T, typename CT>
class Callback_Depo_getName : public Callback_Depo_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Depo_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        DepoPrx proxy = DepoPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_getName.
 */
template<class T, typename CT> Callback_Depo_getNamePtr
newCallback_Depo_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_getName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Depo::begin_getName.
 */
template<class T, typename CT> Callback_Depo_getNamePtr
newCallback_Depo_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Depo_getName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Tram::begin_getLocation.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getLocation.
 */
template<class T>
class CallbackNC_Tram_getLocation : public Callback_Tram_getLocation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TramStopPrx&);

    CallbackNC_Tram_getLocation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        TramStopPrx ret;
        try
        {
            ret = proxy->end_getLocation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getLocation.
 */
template<class T> Callback_Tram_getLocationPtr
newCallback_Tram_getLocation(const IceUtil::Handle<T>& instance, void (T::*cb)(const TramStopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getLocation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getLocation.
 */
template<class T> Callback_Tram_getLocationPtr
newCallback_Tram_getLocation(T* instance, void (T::*cb)(const TramStopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getLocation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Tram::begin_getLocation.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getLocation.
 */
template<class T, typename CT>
class Callback_Tram_getLocation : public Callback_Tram_getLocation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TramStopPrx&, const CT&);

    Callback_Tram_getLocation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        TramStopPrx ret;
        try
        {
            ret = proxy->end_getLocation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getLocation.
 */
template<class T, typename CT> Callback_Tram_getLocationPtr
newCallback_Tram_getLocation(const IceUtil::Handle<T>& instance, void (T::*cb)(const TramStopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getLocation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getLocation.
 */
template<class T, typename CT> Callback_Tram_getLocationPtr
newCallback_Tram_getLocation(T* instance, void (T::*cb)(const TramStopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getLocation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Tram::begin_getLine.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getLine.
 */
template<class T>
class CallbackNC_Tram_getLine : public Callback_Tram_getLine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LinePrx&);

    CallbackNC_Tram_getLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        LinePrx ret;
        try
        {
            ret = proxy->end_getLine(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getLine.
 */
template<class T> Callback_Tram_getLinePtr
newCallback_Tram_getLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const LinePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getLine.
 */
template<class T> Callback_Tram_getLinePtr
newCallback_Tram_getLine(T* instance, void (T::*cb)(const LinePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getLine<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Tram::begin_getLine.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getLine.
 */
template<class T, typename CT>
class Callback_Tram_getLine : public Callback_Tram_getLine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LinePrx&, const CT&);

    Callback_Tram_getLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        LinePrx ret;
        try
        {
            ret = proxy->end_getLine(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getLine.
 */
template<class T, typename CT> Callback_Tram_getLinePtr
newCallback_Tram_getLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const LinePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getLine.
 */
template<class T, typename CT> Callback_Tram_getLinePtr
newCallback_Tram_getLine(T* instance, void (T::*cb)(const LinePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Tram::begin_setLine.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_setLine.
 */
template<class T>
class CallbackNC_Tram_setLine : public Callback_Tram_setLine_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Tram_setLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_setLine.
 */
template<class T> Callback_Tram_setLinePtr
newCallback_Tram_setLine(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_setLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_setLine.
 */
template<class T> Callback_Tram_setLinePtr
newCallback_Tram_setLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_setLine<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_setLine.
 */
template<class T> Callback_Tram_setLinePtr
newCallback_Tram_setLine(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_setLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_setLine.
 */
template<class T> Callback_Tram_setLinePtr
newCallback_Tram_setLine(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_setLine<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Tram::begin_setLine.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_setLine.
 */
template<class T, typename CT>
class Callback_Tram_setLine : public Callback_Tram_setLine_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Tram_setLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_setLine.
 */
template<class T, typename CT> Callback_Tram_setLinePtr
newCallback_Tram_setLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_setLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_setLine.
 */
template<class T, typename CT> Callback_Tram_setLinePtr
newCallback_Tram_setLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_setLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_setLine.
 */
template<class T, typename CT> Callback_Tram_setLinePtr
newCallback_Tram_setLine(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_setLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_setLine.
 */
template<class T, typename CT> Callback_Tram_setLinePtr
newCallback_Tram_setLine(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_setLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Tram::begin_getNextStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getNextStops.
 */
template<class T>
class CallbackNC_Tram_getNextStops : public Callback_Tram_getNextStops_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StopList&);

    CallbackNC_Tram_getNextStops(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        StopList ret;
        try
        {
            ret = proxy->end_getNextStops(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getNextStops.
 */
template<class T> Callback_Tram_getNextStopsPtr
newCallback_Tram_getNextStops(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getNextStops<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getNextStops.
 */
template<class T> Callback_Tram_getNextStopsPtr
newCallback_Tram_getNextStops(T* instance, void (T::*cb)(const StopList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getNextStops<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Tram::begin_getNextStops.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getNextStops.
 */
template<class T, typename CT>
class Callback_Tram_getNextStops : public Callback_Tram_getNextStops_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StopList&, const CT&);

    Callback_Tram_getNextStops(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        StopList ret;
        try
        {
            ret = proxy->end_getNextStops(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getNextStops.
 */
template<class T, typename CT> Callback_Tram_getNextStopsPtr
newCallback_Tram_getNextStops(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getNextStops<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getNextStops.
 */
template<class T, typename CT> Callback_Tram_getNextStopsPtr
newCallback_Tram_getNextStops(T* instance, void (T::*cb)(const StopList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getNextStops<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Tram::begin_RegisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_RegisterPassenger.
 */
template<class T>
class CallbackNC_Tram_RegisterPassenger : public Callback_Tram_RegisterPassenger_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Tram_RegisterPassenger(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_RegisterPassenger.
 */
template<class T> Callback_Tram_RegisterPassengerPtr
newCallback_Tram_RegisterPassenger(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_RegisterPassenger<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_RegisterPassenger.
 */
template<class T> Callback_Tram_RegisterPassengerPtr
newCallback_Tram_RegisterPassenger(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_RegisterPassenger<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_RegisterPassenger.
 */
template<class T> Callback_Tram_RegisterPassengerPtr
newCallback_Tram_RegisterPassenger(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_RegisterPassenger<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_RegisterPassenger.
 */
template<class T> Callback_Tram_RegisterPassengerPtr
newCallback_Tram_RegisterPassenger(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_RegisterPassenger<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Tram::begin_RegisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_RegisterPassenger.
 */
template<class T, typename CT>
class Callback_Tram_RegisterPassenger : public Callback_Tram_RegisterPassenger_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Tram_RegisterPassenger(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_RegisterPassenger.
 */
template<class T, typename CT> Callback_Tram_RegisterPassengerPtr
newCallback_Tram_RegisterPassenger(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_RegisterPassenger<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_RegisterPassenger.
 */
template<class T, typename CT> Callback_Tram_RegisterPassengerPtr
newCallback_Tram_RegisterPassenger(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_RegisterPassenger<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_RegisterPassenger.
 */
template<class T, typename CT> Callback_Tram_RegisterPassengerPtr
newCallback_Tram_RegisterPassenger(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_RegisterPassenger<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_RegisterPassenger.
 */
template<class T, typename CT> Callback_Tram_RegisterPassengerPtr
newCallback_Tram_RegisterPassenger(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_RegisterPassenger<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Tram::begin_UnregisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_UnregisterPassenger.
 */
template<class T>
class CallbackNC_Tram_UnregisterPassenger : public Callback_Tram_UnregisterPassenger_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Tram_UnregisterPassenger(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_UnregisterPassenger.
 */
template<class T> Callback_Tram_UnregisterPassengerPtr
newCallback_Tram_UnregisterPassenger(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_UnregisterPassenger<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_UnregisterPassenger.
 */
template<class T> Callback_Tram_UnregisterPassengerPtr
newCallback_Tram_UnregisterPassenger(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_UnregisterPassenger<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_UnregisterPassenger.
 */
template<class T> Callback_Tram_UnregisterPassengerPtr
newCallback_Tram_UnregisterPassenger(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_UnregisterPassenger<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_UnregisterPassenger.
 */
template<class T> Callback_Tram_UnregisterPassengerPtr
newCallback_Tram_UnregisterPassenger(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_UnregisterPassenger<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Tram::begin_UnregisterPassenger.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_UnregisterPassenger.
 */
template<class T, typename CT>
class Callback_Tram_UnregisterPassenger : public Callback_Tram_UnregisterPassenger_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Tram_UnregisterPassenger(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_UnregisterPassenger.
 */
template<class T, typename CT> Callback_Tram_UnregisterPassengerPtr
newCallback_Tram_UnregisterPassenger(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_UnregisterPassenger<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_UnregisterPassenger.
 */
template<class T, typename CT> Callback_Tram_UnregisterPassengerPtr
newCallback_Tram_UnregisterPassenger(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_UnregisterPassenger<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_UnregisterPassenger.
 */
template<class T, typename CT> Callback_Tram_UnregisterPassengerPtr
newCallback_Tram_UnregisterPassenger(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_UnregisterPassenger<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_UnregisterPassenger.
 */
template<class T, typename CT> Callback_Tram_UnregisterPassengerPtr
newCallback_Tram_UnregisterPassenger(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_UnregisterPassenger<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Tram::begin_getStockNumber.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getStockNumber.
 */
template<class T>
class CallbackNC_Tram_getStockNumber : public Callback_Tram_getStockNumber_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Tram_getStockNumber(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getStockNumber(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getStockNumber.
 */
template<class T> Callback_Tram_getStockNumberPtr
newCallback_Tram_getStockNumber(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getStockNumber<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getStockNumber.
 */
template<class T> Callback_Tram_getStockNumberPtr
newCallback_Tram_getStockNumber(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getStockNumber<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Tram::begin_getStockNumber.
 * Create a wrapper instance by calling ::SIP::newCallback_Tram_getStockNumber.
 */
template<class T, typename CT>
class Callback_Tram_getStockNumber : public Callback_Tram_getStockNumber_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Tram_getStockNumber(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getStockNumber(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getStockNumber.
 */
template<class T, typename CT> Callback_Tram_getStockNumberPtr
newCallback_Tram_getStockNumber(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getStockNumber<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Tram::begin_getStockNumber.
 */
template<class T, typename CT> Callback_Tram_getStockNumberPtr
newCallback_Tram_getStockNumber(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getStockNumber<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Passenger::begin_updateTramInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_Passenger_updateTramInfo.
 */
template<class T>
class CallbackNC_Passenger_updateTramInfo : public Callback_Passenger_updateTramInfo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Passenger_updateTramInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateTramInfo.
 */
template<class T> Callback_Passenger_updateTramInfoPtr
newCallback_Passenger_updateTramInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Passenger_updateTramInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateTramInfo.
 */
template<class T> Callback_Passenger_updateTramInfoPtr
newCallback_Passenger_updateTramInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Passenger_updateTramInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateTramInfo.
 */
template<class T> Callback_Passenger_updateTramInfoPtr
newCallback_Passenger_updateTramInfo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Passenger_updateTramInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateTramInfo.
 */
template<class T> Callback_Passenger_updateTramInfoPtr
newCallback_Passenger_updateTramInfo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Passenger_updateTramInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Passenger::begin_updateTramInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_Passenger_updateTramInfo.
 */
template<class T, typename CT>
class Callback_Passenger_updateTramInfo : public Callback_Passenger_updateTramInfo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Passenger_updateTramInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateTramInfo.
 */
template<class T, typename CT> Callback_Passenger_updateTramInfoPtr
newCallback_Passenger_updateTramInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Passenger_updateTramInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateTramInfo.
 */
template<class T, typename CT> Callback_Passenger_updateTramInfoPtr
newCallback_Passenger_updateTramInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Passenger_updateTramInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateTramInfo.
 */
template<class T, typename CT> Callback_Passenger_updateTramInfoPtr
newCallback_Passenger_updateTramInfo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Passenger_updateTramInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateTramInfo.
 */
template<class T, typename CT> Callback_Passenger_updateTramInfoPtr
newCallback_Passenger_updateTramInfo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Passenger_updateTramInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::SIP::Passenger::begin_updateStopInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_Passenger_updateStopInfo.
 */
template<class T>
class CallbackNC_Passenger_updateStopInfo : public Callback_Passenger_updateStopInfo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Passenger_updateStopInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateStopInfo.
 */
template<class T> Callback_Passenger_updateStopInfoPtr
newCallback_Passenger_updateStopInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Passenger_updateStopInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateStopInfo.
 */
template<class T> Callback_Passenger_updateStopInfoPtr
newCallback_Passenger_updateStopInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Passenger_updateStopInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateStopInfo.
 */
template<class T> Callback_Passenger_updateStopInfoPtr
newCallback_Passenger_updateStopInfo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Passenger_updateStopInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateStopInfo.
 */
template<class T> Callback_Passenger_updateStopInfoPtr
newCallback_Passenger_updateStopInfo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Passenger_updateStopInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::SIP::Passenger::begin_updateStopInfo.
 * Create a wrapper instance by calling ::SIP::newCallback_Passenger_updateStopInfo.
 */
template<class T, typename CT>
class Callback_Passenger_updateStopInfo : public Callback_Passenger_updateStopInfo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Passenger_updateStopInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateStopInfo.
 */
template<class T, typename CT> Callback_Passenger_updateStopInfoPtr
newCallback_Passenger_updateStopInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Passenger_updateStopInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateStopInfo.
 */
template<class T, typename CT> Callback_Passenger_updateStopInfoPtr
newCallback_Passenger_updateStopInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Passenger_updateStopInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateStopInfo.
 */
template<class T, typename CT> Callback_Passenger_updateStopInfoPtr
newCallback_Passenger_updateStopInfo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Passenger_updateStopInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::SIP::Passenger::begin_updateStopInfo.
 */
template<class T, typename CT> Callback_Passenger_updateStopInfoPtr
newCallback_Passenger_updateStopInfo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Passenger_updateStopInfo<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
